
@article{kopetz2002,
  title = {Temporal {{Composability}}},
  volume = {13},
  issn = {0956-3385},
  doi = {10.1049/cce:20020401},
  abstract = {The constructive design of dependable distributed real-time systems out of pre-validated components requires precise interface specifications of the components in the temporal domain and in the value domain. This paper focuses on the temporal specification of interfaces in composable distributed real-time systems and establishes four principles of composability (independent development of nodes, stability of prior services, performability of the communication system, and replica determinism). It presents the temporal firewall interface that forms a fully specified operational interface of a component. The paper explains how the temporal firewall interface supports the four principles of composability. It then classifies interfaces from the point of view of composability and shows how these interfaces correspond to the time-triggered and event-triggered communication paradigms.},
  timestamp = {2015-03-17T11:14:06Z},
  number = {4},
  journal = {Computing Control Engineering Journal},
  author = {Kopetz, Hermann and Obermaisser, Roman},
  month = aug,
  year = {2002},
  keywords = {application program interfaces,authorisation,communication system performability,component interface specifications,composable distributed real-time systems,constructive design,dependable distributed real-time systems,distributed processing,embedded systems,event-triggered communication paradigm,formal specification,fully specified operational interface,independent node development,pre-validated components,prior service stability,real-time embedded systems,replica determinism,software fault tolerance,subroutines,temporal composability,temporal domain,temporal firewall interface,temporal specification,time-triggered communication paradigm,value domain},
  pages = {156--162},
  file = {Kopetz and Obermaisser - 2002 - Temporal Composability.pdf:/home/moiri/Dropbox/papers/Kopetz and Obermaisser - 2002 - Temporal Composability.pdf:application/pdf}
}

@book{posix2009,
  series = {IEEE Std 1003.1-2008},
  title = {Information Technology - {{Portable Operating System Interface}} ({{POSIX}}) {{Base Specifications}}, {{Issue}} 7},
  isbn = {978-0-7381-6032-0},
  timestamp = {2017-07-27T16:53:38Z},
  publisher = {{IEEE}},
  author = {{The Open Group and IEEE}},
  month = sep,
  year = {2009}
}

@incollection{deAlfaro2001,
  series = {Lecture Notes in Computer Science},
  title = {Interface {{Theories}} for {{Component}}-{{Based Design}}},
  copyright = {\textcopyright{}2001 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-42673-8 978-3-540-45449-6},
  abstract = {We classify component-based models of computation into component models and interface models. A component model specifies for each component howthe component behaves in an arbitrary environment; an interface model specifies for each component what the component expects from the environment. Component models support compositional abstraction, and therefore component-based verification. Interface models support compositional refinement, and therefore componentbased design. Many aspects of interface models, such as compatibility and refinement checking between interfaces, are properly viewed in a gametheoretic setting, where the input and output values of an interface are chosen by different players.},
  language = {english},
  timestamp = {2017-06-09T09:31:51Z},
  number = {2211},
  urldate = {2016-09-13},
  booktitle = {Embedded {{Software}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {{de Alfaro}, Luca and Henzinger, Thomas A.},
  editor = {Henzinger, Thomas A. and Kirsch, Christoph M.},
  month = oct,
  year = {2001},
  keywords = {Logics and Meanings of Programs,Software Engineering/Programming and Operating Systems,Special Purpose and Application-Based Systems,Theory of Computation},
  pages = {148--165},
  file = {Alfaro and Henzinger - 2001 - Interface Theories for Component-Based Design.pdf:/home/moiri/Dropbox/papers/Alfaro and Henzinger - 2001 - Interface Theories for Component-Based Design.pdf:application/pdf},
  doi = {10.1007/3-540-45449-7_11}
}

@article{grelck2010,
  title = {Asynchronous {{Stream Processing}} with {{S}}-{{Net}}},
  volume = {38},
  issn = {0885-7458, 1573-7640},
  doi = {10.1007/s10766-009-0121-x},
  abstract = {We present the rationale and design of S-Net, a coordination language for asynchronous stream processing. The language achieves a near-complete separation between the application code, written in any conventional programming language, and the coordination/communication code written in S-Net. Our approach supports a component technology with flexible software reuse. No extension of the conventional language is required. The interface between S-Net and the application code is in terms of one additional library function. The application code is componentised and presented to S-Net as a set of components, called boxes, each encapsulating a single tuple-to-tuple function. Apart from the boxes defined using an external compute language, S-Net features two built-in boxes: one for network housekeeping and one for data-flow style synchronisation. Streaming network composition under S-Net is based on four network combinators, which have both deterministic and nondeterministic versions. Flexible software reuse is comprehensive, with the box interfaces and even the network structure being subject to subtyping. We propose an inheritance mechanism, named flow inheritance, that is specifically geared towards stream processing. The paper summarises the essential language constructs and type concepts and gives a short application example.},
  language = {english},
  timestamp = {2017-06-09T09:33:14Z},
  number = {1},
  urldate = {2014-09-29},
  journal = {Int J Parallel Prog},
  author = {Grelck, Clemens and Scholz, Sven-Bodo and Shafarenko, Alex},
  month = feb,
  year = {2010},
  keywords = {Component system,Coordination language,Declarative multicore programming,Processor Architectures,Record subtyping,Software Engineering/Programming and Operating Systems,Stream processing,Theory of Computation},
  pages = {38--67},
  file = {Grelck et al. - 2010 - Asynchronous Stream Processing with S-Net.pdf:/home/moiri/Dropbox/papers/Grelck et al. - 2010 - Asynchronous Stream Processing with S-Net.pdf:application/pdf}
}

@incollection{burke2011,
  title = {Concurrent {{Collections Programming Model}}},
  copyright = {\textcopyright{}2011 Springer Science+Business Media, LLC},
  isbn = {978-0-387-09765-7 978-0-387-09766-4},
  abstract = {SynonymsCnC, TStreamsDefinitionConcurrent Collections (CnC) is a parallel programming model, with an execution semantics that is influenced by dynamic dataflow, stream-processing, and tuple spaces. The three main constructs in the CnC programming model are step collections, data collections, and control collections. A step collection corresponds to a computation, and its instances correspond to invocations of that computation that consume and produce data items. A data collection corresponds to a set of data items, indexed by item tags that can be accessed via put and get operations; once put, data items cannot be overwritten and are required to be immutable. A control collection corresponds to a factory [9] for step instances. A put operation on a control collection with a control tag results in the prescription (creation) of step instances from one or more step collections with that tag passed as an input argument. These collections and their relationships are defin ...},
  language = {en},
  timestamp = {2014-10-16T10:48:49Z},
  urldate = {2014-10-16},
  booktitle = {Encyclopedia of {{Parallel Computing}}},
  publisher = {{Springer US}},
  author = {Burke, Michael G. and Knobe, Kathleen and Newton, Ryan and Sarkar, Vivek},
  editor = {Padua, David},
  month = jan,
  year = {2011},
  keywords = {CnC,Processor Architectures,Programming Languages; Compilers; Interpreters,Software Engineering/Programming and Operating Systems,Special Purpose and Application-Based Systems,System Performance and Evaluation},
  pages = {364--371},
  file = {Burke et al. - 2011 - Concurrent Collections Programming Model.pdf:/home/moiri/Dropbox/papers/Burke et al. - 2011 - Concurrent Collections Programming Model.pdf:application/pdf}
}

@article{hoare1978,
  title = {Communicating {{Sequential Processes}}},
  volume = {21},
  issn = {0001-0782},
  doi = {10.1145/359576.359585},
  abstract = {This paper suggests that input and output are basic primitives of programming and that parallel composition of communicating sequential processes is a fundamental program structuring method. When combined with a development of Dijkstra's guarded command, these concepts are surprisingly versatile. Their use is illustrated by sample solutions of a variety of a familiar programming exercises.},
  language = {english},
  timestamp = {2017-06-09T09:33:38Z},
  number = {8},
  urldate = {2015-01-08},
  journal = {Commun. ACM},
  author = {Hoare, Charles A. R.},
  month = aug,
  year = {1978},
  keywords = {classes,concurrency,conditional critical regions,coroutines,data representations,guarded commands,input,iterative arrays,monitors,multiple entries,multiple exits,nondeterminacy,output,parallel programming,procedures,programming,programming languages,programming primitives,program structures,recursion},
  pages = {666--677}
}

@incollection{papadopoulos1998,
  title = {Coordination {{Models}} and {{Languages}}},
  volume = {46},
  isbn = {0065-2458},
  abstract = {Abstracts
A new class of models, formalisms, and mechanisms has recently evolved for describing concurrent and distributed computations based on the concept of ``CO-ordination.'' The purpose of a coordination model and associated language is to provide a means of integrating a number of possibly heterogeneous components by interfacing with each component in such a way that the collective set forms a single application that can execute on and take advantage of parallel and distributed systems. In this chapter we initially define and present in sufficient detail the fundamental concepts of what constitutes a coordination model or language. We then go on to classify these models and languages as either ``data-driven'' or ``control-driven'' (also called ``process-'' or ``task-oriented''). In the process, the main existing coordination models and languages are described in sufficient detail to let the reader appreciate their features and put them into perspective with respect to each other. The chapter ends with a discussion comparing the various models and some aonclusions.},
  language = {english},
  timestamp = {2017-06-09T09:34:31Z},
  urldate = {2014-09-29},
  booktitle = {Advances in {{Computers}}},
  publisher = {{Elsevier}},
  author = {Papadopoulos, George A. and Arbab, Farhad},
  year = {1998},
  keywords = {coordination language,survey},
  pages = {329--400},
  file = {Papadopoulos and Arbab - 1998 - Coordination Models and Languages.pdf:/home/moiri/Dropbox/papers/Papadopoulos and Arbab - 1998 - Coordination Models and Languages.pdf:application/pdf}
}

@inproceedings{deAlfaro2001a,
  address = {New York, NY, USA},
  series = {ESEC/FSE-9},
  title = {Interface {{Automata}}},
  isbn = {978-1-58113-390-5},
  doi = {10.1145/503209.503226},
  abstract = {Conventional type systems specify interfaces in terms of values and domains. We present a light-weight formalism that captures the temporal aspects of software component interfaces. Specifically, we use an automata-based language to capture both input assumptions about the order in which the methods of a component are called, and output guarantees about the order in which the component calls external methods. The formalism supports automatic compatability checks between interface models, and thus constitutes a type system for component interaction. Unlike traditional uses of automata, our formalism is based on an optimistic approach to composition, and on an alternating approach to design refinement. According to the optimistic approach, two components are compatible if there is some environment that can make them work together. According to the alternating approach, one interface refines another if it has weaker input assumptions, and stronger output guarantees. We show that these notions have game-theoretic foundations that lead to efficient algorithms for checking compatibility and refinement.},
  language = {english},
  timestamp = {2017-06-09T09:31:39Z},
  urldate = {2015-12-04},
  booktitle = {Proceedings of the 8th {{European Software Engineering Conference Held Jointly}} with 9th {{ACM SIGSOFT International Symposium}} on {{Foundations}} of {{Software Engineering}}},
  publisher = {{ACM}},
  author = {{de Alfaro}, Luca and Henzinger, Thomas A.},
  year = {2001},
  pages = {109--120},
  file = {de Alfaro and Henzinger - 2001 - Interface Automata.pdf:/home/moiri/Dropbox/papers/de Alfaro and Henzinger - 2001 - Interface Automata.pdf:application/pdf}
}

@inproceedings{kahn1974,
  title = {The {{Semantics}} of a {{Simple Language}} for {{Parallel Programming}}},
  volume = {74},
  timestamp = {2015-05-11T10:56:17Z},
  booktitle = {In {{Information Processing}}'74: {{Proceedings}} of the {{IFIP Congress}}},
  author = {Kahn, Gilles},
  year = {1974},
  pages = {471--475},
  file = {Gilles - 1974 - The Semantics of a Simple Language for Parallel Programming.pdf:/home/moiri/Dropbox/papers/Gilles - 1974 - The Semantics of a Simple Language for Parallel Programming.pdf:application/pdf}
}

@article{stephens1997,
  title = {A {{Survey}} of {{Stream Processing}}},
  volume = {34},
  issn = {0001-5903, 1432-0525},
  doi = {10.1007/s002360050095},
  abstract = {Stream processing is a term that is used widely in the literature to describe a variety of systems. We present an overview of the historical development of stream processing and a detailed discussion of the different languages and techniques for programming with streams that can be found in the literature. This includes an analysis of dataflow, specialized functional and logic programming with streams, reactive systems, signal processing systems, and the use of streams in the design and verification of hardware. The aim of this survey is an analysis of the development of each of these specialized topics to determine if a general theory of stream processing has emerged. As such, we discuss and classify the different classes of stream processing systems found in the literature from the perspective of programming primitives, implementation techniques, and computability issues, including a comparison of the semantic models that are used to formalize stream based computation.},
  language = {english},
  timestamp = {2017-06-09T09:34:39Z},
  number = {7},
  urldate = {2014-10-01},
  journal = {Acta Informatica},
  author = {Stephens, Robert},
  month = jul,
  year = {1997},
  keywords = {stream processing,survey},
  pages = {491--541},
  file = {Stephens - 1997 - A Survey of Stream Processing.pdf:/home/moiri/Dropbox/papers/Stephens - 1997 - A Survey of Stream Processing.pdf:application/pdf}
}

@misc{powell2002,
  address = {Grenoble, France},
  type = {Workshop Presentation},
  title = {Time/{{Event Triggering}} Is {{Orthogonal}} to {{State}}/{{Event Observation}}},
  timestamp = {2015-04-20T12:01:54Z},
  author = {Powell, Davis},
  month = oct,
  year = {2002},
  file = {Powell - 2002 - TimeEvent Triggering is Orthogonal to StateEvent Observation.pdf:/home/moiri/Documents/svn-cps/papers/p132_EBCCSP15_mixed_crit_interfaces/resource/Powell - 2002 - TimeEvent Triggering is Orthogonal to StateEvent Observation.pdf:application/pdf},
  howpublished = {Workshop Presentation}
}

@incollection{arbab2006,
  title = {Composition of {{Interacting Computations}}},
  copyright = {\textcopyright{}2006 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-34666-1 978-3-540-34874-0},
  abstract = {The field of programming has been concerned with software composition since its very inception. Our models for software composition have brought us up to a new plateau of software complexity and composition. To tackle the challenges of composition at this level requires new models for software composition centered on interaction as a first-class concept. Interaction has been studied as an inseparable concern within concurrency theory. Curiously, however, interaction has not been seriously considered as a first-class concept in constructive models of computation. Composition of systems out of autonomous subsystems pivots on coordination concerns that center on interaction. Coordination models and languages represent a recent approach to design and development of concurrent systems. In this chapter, we present a brief overview of coordination models and languages, followed by a framework for their classification. We then focus on a specific coordination language, called Reo, and demonstrate how it provides a powerful and expressive model for flexible composition of behavior through interaction. Reo serves as a good example of a constructive model of computation that treats interaction as a (in fact, the only) first-class concept. It uniquely focuses on the compositional construction of connectors that enable and coordinate the interactions among the constituents in a concurrent system, without their knowledge. We show how Reo allows complex behavior in a system to emerge as a composition of primitive interactions.},
  language = {en},
  timestamp = {2014-12-01T10:53:07Z},
  urldate = {2014-12-01},
  booktitle = {Interactive {{Computation}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Arbab, Farhad},
  editor = {Goldin, Dina and Smolka, Scott A. and Wegner, Peter},
  month = jan,
  year = {2006},
  keywords = {Models and Principles,Programming Techniques,survey,Theory of Computation,User Interfaces and Human Computer Interaction},
  pages = {277--321},
  file = {Arbab - 2006 - Composition of Interacting Computations.pdf:/home/moiri/Dropbox/papers/Arbab - 2006 - Composition of Interacting Computations.pdf:application/pdf}
}

@article{ferreira2002,
  title = {The {{FTT}}-{{CAN Protocol}} for {{Flexibility}} in {{Safety}}-{{Critical Systems}}},
  volume = {22},
  issn = {0272-1732},
  doi = {10.1109/MM.2002.1028475},
  abstract = {A new communication protocol for distributed embedded systems attempts to find a compromise between the often-opposing goals of system flexibility and safety},
  timestamp = {2015-03-12T14:36:42Z},
  number = {4},
  journal = {IEEE Micro},
  author = {Ferreira, Joaquim and Pedreiras, Piaulo and Almeida, Luis and Fonseca, Jos\'e A.},
  month = jul,
  year = {2002},
  keywords = {automotive engineering,automotive industry,Bandwidth,communication protocol,Communication system control,Communication system traffic control,controller area networks,Control systems,Delay,Distributed control,flexible time-triggered communication on CAN,FTT-CAN,Interference elimination,protocol,Protocols,Safety,safety-critical software,safety-critical systems,Time-Triggered Controller Area Network,TT-CAN},
  pages = {46--55},
  file = {Ferreira et al. - 2002 - The FTT-CAN Protocol for Flexibility in Safety-Critical Systems.pdf:/home/moiri/Dropbox/papers/Ferreira et al. - 2002 - The FTT-CAN Protocol for Flexibility in Safety-Critical Systems.pdf:application/pdf}
}

@inproceedings{maurer2015a,
  address = {Krakow, Poland},
  title = {Cross-Criticality {{Interfaces}} for {{Cyber}}-Physical {{Systems}}},
  doi = {10.1109/EBCCSP.2015.7300670},
  timestamp = {2016-06-07T17:27:39Z},
  booktitle = {Proc. 1st {{IEEE Int}}'l {{Conference}} on {{Event}}-Based {{Control}}, {{Communication}}, and {{Signal Processing}}},
  publisher = {{IEEE}},
  author = {Maurer, Simon and Kirner, Raimund},
  month = jun,
  year = {2015},
  pages = {1--8},
  file = {Maurer and Kirner - 2015 - Cross-criticality Interfaces for Cyber-physical Systems.pdf:/home/moiri/Dropbox/papers/Maurer and Kirner - 2015 - Cross-criticality Interfaces for Cyber-physical Systems.pdf:application/pdf}
}

@incollection{aldred2005,
  series = {Lecture Notes in Computer Science},
  title = {On the {{Notion}} of {{Coupling}} in {{Communication Middleware}}},
  copyright = {\textcopyright{}2005 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-29738-3 978-3-540-32120-0},
  abstract = {It is well accepted that different types of distributed architectures require different levels of coupling. For example, in client-server and three-tier architectures the application components are generally tightly coupled between them and with the underlying communication middleware. Meanwhile, in off-line transaction processing, grid computing and mobile application architectures, the degree of coupling between application components and with the underlying middleware needs to be minimised along different dimensions. In the literature, terms such as synchronous, asynchronous, blocking, non-blocking, directed, and non-directed are generally used to refer to the degree of coupling required by a given architecture or provided by a given middleware. However, these terms are used with various connotations by different authors and middleware vendors. And while several informal definitions of these terms have been provided, there is a lack of an overarching framework with a formal grounding upon which software architects can rely to unambiguously communicate architectural requirements with respect to coupling. This paper addresses this gap by: (i) identifying and formally defining three dimensions of coupling; (ii) relating these dimensions to existing communication middleware; and (iii) proposing notational elements for representing coupling configurations. The identified dimensions provide the basis for a classification of middleware which can be used as a selection instrument.},
  language = {en},
  timestamp = {2015-01-15T11:11:30Z},
  number = {3761},
  urldate = {2015-01-15},
  booktitle = {On the {{Move}} to {{Meaningful Internet Systems}} 2005: {{CoopIS}}, {{DOA}}, and {{ODBASE}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Aldred, Lachlan and van der Aalst, Wil M. P. and Dumas, Marlon and ter Hofstede, Arthur H. M.},
  editor = {Meersman, Robert and Tari, Zahir},
  month = jan,
  year = {2005},
  keywords = {Artificial Intelligence (incl. Robotics),Computer Communication Networks,Database Management,Information Storage and Retrieval,Information Systems Applications (incl.Internet),User Interfaces and Human Computer Interaction},
  pages = {1015--1033},
  file = {Aldred et al. - 2005 - On the Notion of Coupling in Communication Middleware.pdf:/home/moiri/Dropbox/papers/Aldred et al. - 2005 - On the Notion of Coupling in Communication Middleware.pdf:application/pdf}
}

@inproceedings{arbab1998,
  title = {What {{Do You Mean}}, {{Coordination}}?},
  abstract = {Coordination models and languages represent a new approach to design and development of concurrent systems. The interest in coordination has intensified in the last few years, as evidenced by the increasing number of conferences, tracks, and papers devoted to this topic, and by the recent upsurge of research activity in the theoretical computer science community in this field. The field is relatively new, and while many coordination models and languages form a tight cluster of very similar variants, some others are drastically different and they appear to have nothing in common with each other. All this makes it difficult for the uninitiated to discern the underlying similarities of various approaches to coordination. This paper is an "easy reader" introduction to coordination models and languages, their common aims and purpose, their relevance, and their place in the computing arena. The work on coordination at CWI is presented here as a specific example. 1 Introduction  The size, spe...},
  timestamp = {2017-08-17T16:05:52Z},
  booktitle = {Bulletin of the {{Dutch Association}} for {{Theoretical Computer Science}} ({{NVTI}})},
  author = {Arbab, Farhad},
  year = {1998},
  pages = {11--22},
  file = {Arbab - 1998 - What Do You Mean, Coordination.pdf:/home/moiri/Dropbox/papers/Arbab - 1998 - What Do You Mean, Coordination.pdf:application/pdf}
}

@inproceedings{pop2002,
  address = {New York, NY, USA},
  series = {CODES '02},
  title = {Holistic {{Scheduling}} and {{Analysis}} of {{Mixed Time}}/{{Event}}-Triggered {{Distributed Embedded Systems}}},
  isbn = {1-58113-542-4},
  doi = {10.1145/774789.774828},
  timestamp = {2015-02-04T15:41:59Z},
  urldate = {2015-02-04},
  booktitle = {Proceedings of the {{Tenth International Symposium}} on {{Hardware}}/{{Software Codesign}}},
  publisher = {{ACM}},
  author = {Pop, Traian and Eles, Petru and Peng, Zebo},
  year = {2002},
  pages = {187--192},
  file = {Pop et al. - 2002 - Holistic Scheduling and Analysis of Mixed TimeEvent-triggered Distributed Embedded Systems.pdf:/home/moiri/Dropbox/papers/Pop et al. - 2002 - Holistic Scheduling and Analysis of Mixed TimeEvent-triggered Distributed Embedded Systems.pdf:application/pdf}
}

@incollection{henzinger2001,
  series = {Lecture Notes in Computer Science},
  title = {Giotto: {{A Time}}-{{Triggered Language}} for {{Embedded Programming}}},
  copyright = {\textcopyright{}2001 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-42673-8 978-3-540-45449-6},
  shorttitle = {Giotto},
  abstract = {Giotto provides an abstract programmer's model for the implementation of embedded control systems with hard real-time constraints. A typical control application consists of periodic software tasks together with a mode switching logic for enabling and disabling tasks. Giotto specifies time-triggered sensor readings, task invocations, and mode switches independent of any implementation platform. Giotto can be annotated with platform constraints such as task-to-host mappings, and task and communication schedules. The annotations are directives for the Giotto compiler, but they do not alter the functionality and timing of a Giotto program. By separating the platform-independent from the platform-dependent concerns, Giotto enables a great deal of flexibility in choosing control platforms as well as a great deal of automation in the validation and synthesis of control software. The time-triggered nature of Giotto achieves timing predictability, which makes Giotto particularly suitable for safety-critical applications.},
  language = {en},
  timestamp = {2014-10-08T09:25:36Z},
  number = {2211},
  urldate = {2014-09-29},
  booktitle = {Embedded {{Software}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Henzinger, Thomas A. and Horowitz, Benjamin and Kirsch, Christoph Meyer},
  month = jan,
  year = {2001},
  keywords = {coordination language,Giotto,real-time},
  pages = {166--184},
  file = {Henzinger et al. - 2001 - Giotto A Time-Triggered Language for Embedded Programming.pdf:/home/moiri/Dropbox/papers/Henzinger et al. - 2001 - Giotto A Time-Triggered Language for Embedded Programming.pdf:application/pdf}
}

@article{omicini2011,
  title = {Coordination {{Models}} and {{Languages}}: {{From Parallel Computing}} to {{Self}}-{{Organisation}}.},
  volume = {26},
  issn = {1469-8005},
  shorttitle = {Coordination Models and Languages},
  doi = {10.1017/S026988891000041X},
  timestamp = {2014-10-02T10:52:09Z},
  journal = {Knowledge Eng. Review},
  author = {Omicini, Andrea and Viroli, Mirko},
  year = {2011},
  keywords = {coordination language,survey},
  pages = {53--59},
  file = {Omicini and Viroli - 2011 - Coordination Models and Languages From Parallel Computing to Self-Organisation..pdf:/home/moiri/Dropbox/papers/Omicini and Viroli - 2011 - Coordination Models and Languages From Parallel Computing to Self-Organisation..pdf:application/pdf}
}

@inproceedings{zhou2006,
  address = {New York, NY, USA},
  series = {EMSOFT '06},
  title = {A {{Causality Interface}} for {{Deadlock Analysis}} in {{Dataflow}}},
  isbn = {978-1-59593-542-7},
  doi = {10.1145/1176887.1176895},
  abstract = {In this paper, we consider a concurrent model of computation called dataflow, where components (actors) communicate via streams of data tokens. Dataflow semantics has been adopted by experimental and production languages used to design embedded systems. The execution of a dataflow actor is enabled by the availability of its input data. One important question is whether a dataflow model will deadlock (i.e., actors cannot execute due to a data dependency loop). Deadlock in many cases can be determined, although it is generally not decidable. We develop a causality interface for dataflow actors based on the general framework we introduced in [1]and show how this causality information can be algebraically composed so that composition of components acquire causality interfaces that are inferred from their components and the interconnections. We illustrate the use of these causality interfaces to statically analyze for deadlock.},
  language = {english},
  timestamp = {2017-06-09T09:34:56Z},
  urldate = {2016-10-18},
  booktitle = {Proceedings of the 6th {{ACM}} \& {{IEEE International Conference}} on {{Embedded Software}}},
  publisher = {{ACM}},
  author = {Zhou, Ye and Lee, Edward A.},
  year = {2006},
  keywords = {Actor oriented model,actors,behavioral types,causality,Causality Interface,Dataflow,deadlock,interfaces,Interface Theory,Ptolemy II},
  pages = {44--52},
  file = {Zhou and Lee - 2006 - A Causality Interface for Deadlock Analysis in Dataflow.pdf:/home/moiri/Dropbox/papers/Zhou and Lee - 2006 - A Causality Interface for Deadlock Analysis in Dataflow.pdf:application/pdf}
}

@incollection{chakrabarti2003,
  series = {Lecture Notes in Computer Science},
  title = {Resource {{Interfaces}}},
  copyright = {\textcopyright{}2003 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-20223-3 978-3-540-45212-6},
  abstract = {We present a formalism for specifying component interfaces that expose component requirements on limited resources. The formalism permits an algorithmic check if two or more components, when put together, exceed the available resources. Moreover, the formalism can be used to compute the quantity of resources necessary for satisfying the requirements of a collection of components. The formalism can be instantiated in several ways. For example, several components may draw power from the same source. Then, the formalism supports compatibility checks such as: can two components, when put together, achieve their tasks without ever exceeding the available amount of peak power? or, can they achieve their tasks by using no more than the initially available amount of energy (i.e., power accumulated over time)? The corresponding quantitative questions that our algorithms answer are the following: what is the amount of peak power needed for two components to be put together? what is the corresponding amount of initial energy? To solve these questions, we model interfaces with resource requirements as games with quantitative objectives. The games are played on state spaces where each state is labeled by a number (representing, e.g., power consumption), and a play produces an infinite path of labels. The objective may be, for example, to minimize the largest label that occurs during a play. We illustrate our approach by modeling compatibility questions for the components of robot control software, and of wireless sensor networks.},
  language = {en},
  timestamp = {2016-10-18T16:57:41Z},
  number = {2855},
  urldate = {2016-10-18},
  booktitle = {Embedded {{Software}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Chakrabarti, Arindam and de Alfaro, Luca and Henzinger, Thomas A. and Stoelinga, Mari{\"e}lle},
  editor = {Alur, Rajeev and Lee, Insup},
  month = oct,
  year = {2003},
  keywords = {Computer Applications,Operating Systems,Programming Languages; Compilers; Interpreters,Programming Techniques,Software engineering,Special Purpose and Application-Based Systems},
  pages = {117--133},
  file = {Chakrabarti et al. - 2003 - Resource Interfaces.pdf:/home/moiri/Dropbox/papers/Chakrabarti et al. - 2003 - Resource Interfaces.pdf:application/pdf},
  doi = {10.1007/978-3-540-45212-6_9}
}

@article{arbab2004,
  title = {Reo: {{A Channel}}-Based {{Coordination Model}} for {{Component Composition}}},
  volume = {14},
  issn = {1469-8072},
  shorttitle = {Reo},
  doi = {10.1017/S0960129504004153},
  abstract = {In this paper, we present Reo, which forms a paradigm for composition of software components based on the notion of mobile channels. Reo is a channel-based exogenous coordination model in which complex coordinators, called connectors, are compositionally built out of simpler ones. The simplest connectors in Reo are a set of channels with well-defined behaviour supplied by users. Reo can be used as a language for coordination of concurrent processes, or as a `glue language' for compositional construction of connectors that orchestrate component instances in a component-based system. The emphasis in Reo is just on connectors and their composition, and not on the entities that connect to, communicate and cooperate through these connectors. Each connector in Reo imposes a specific coordination pattern on the entities (for example, components) that perform I\&sol;O operations through that connector, without the knowledge of those entities. Channel composition in Reo is a very powerful mechanism for construction of connectors. We demonstrate the expressive power of connector composition in Reo through a number of examples. We show that exogenous coordination patterns that can be expressed as (meta-level) regular expressions over I\&sol;O operations can be composed in Reo out of a small set of only five primitive channel types.},
  timestamp = {2017-03-10T16:52:13Z},
  number = {03},
  urldate = {2014-10-01},
  journal = {Mathematical Structures in Computer Science},
  author = {Arbab, Farhad},
  month = jun,
  year = {2004},
  keywords = {Reo},
  pages = {329--366},
  file = {Arbab - 2004 - Reo A Channel-based Coordination Model for Component Composition.pdf:/home/moiri/Dropbox/papers/Arbab - 2004 - Reo A Channel-based Coordination Model for Component Composition.pdf:application/pdf}
}

@inproceedings{lynch1987,
  address = {New York, NY, USA},
  series = {PODC '87},
  title = {Hierarchical {{Correctness Proofs}} for {{Distributed Algorithms}}},
  isbn = {978-0-89791-239-6},
  doi = {10.1145/41840.41852},
  language = {english},
  timestamp = {2017-06-09T09:34:18Z},
  urldate = {2016-10-18},
  booktitle = {Proceedings of the {{Sixth Annual ACM Symposium}} on {{Principles}} of {{Distributed Computing}}},
  publisher = {{ACM}},
  author = {Lynch, Nancy A. and Tuttle, Mark R.},
  year = {1987},
  keywords = {I/O Automata},
  pages = {137--151},
  file = {Lynch and Tuttle - 1987 - Hierarchical Correctness Proofs for Distributed Algorithms.pdf:/home/moiri/Dropbox/papers/Lynch and Tuttle - 1987 - Hierarchical Correctness Proofs for Distributed Algorithms.pdf:application/pdf}
}

@inproceedings{bergenhem2012,
  title = {Overview of {{Platooning Systems}}},
  timestamp = {2015-09-29T18:39:39Z},
  urldate = {2015-09-29},
  booktitle = {Proceedings of the 19th {{ITS World Congress}}, {{Oct}} 22-26, {{Vienna}}, {{Austria}} (2012)},
  author = {Bergenhem, Carl and Shladover, Steven and Coelingh, Erik and Englund, Christoffer and Tsugawa, Sadayuki},
  year = {2012},
  file = {Bergenhem et al. - 2012 - Overview of Platooning Systems.pdf:/home/moiri/Dropbox/papers/Bergenhem et al. - 2012 - Overview of Platooning Systems.pdf:application/pdf}
}

@book{ptolemaeus2014,
  title = {System {{Design}}, {{Modeling}}, and {{Simulation}} Using {{Ptolemy II}}},
  language = {english},
  timestamp = {2017-06-09T09:34:34Z},
  publisher = {{Ptolemy.org}},
  editor = {Ptolemaeus, Claudius},
  year = {2014},
  file = {Ptolemaeus - 2014 - System Design, Modeling, and Simulation using Ptolemy II.pdf:/home/moiri/Dropbox/papers/Ptolemaeus - 2014 - System Design, Modeling, and Simulation using Ptolemy II.pdf:application/pdf}
}

@article{eugster2003,
  title = {The {{Many Faces}} of {{Publish}}/{{Subscribe}}},
  volume = {35},
  issn = {0360-0300},
  doi = {10.1145/857076.857078},
  abstract = {Well adapted to the loosely coupled nature of distributed interaction in large-scale applications, the publish/subscribe communication paradigm has recently received increasing attention. With systems based on the publish/subscribe interaction scheme, subscribers register their interest in an event, or a pattern of events, and are subsequently asynchronously notified of events generated by publishers. Many variants of the paradigm have recently been proposed, each variant being specifically adapted to some given application or network model. This paper factors out the common denominator underlying these variants: full decoupling of the communicating entities in time, space, and synchronization. We use these three decoupling dimensions to better identify commonalities and divergences with traditional interaction paradigms. The many variations on the theme of publish/subscribe are classified and synthesized. In particular, their respective benefits and shortcomings are discussed both in terms of interfaces and implementations.},
  timestamp = {2015-01-13T18:35:54Z},
  number = {2},
  urldate = {2015-01-13},
  journal = {ACM Comput. Surv.},
  author = {Eugster, Patrick Th. and Felber, Pascal A. and Guerraoui, Rachid and Kermarrec, Anne-Marie},
  month = jun,
  year = {2003},
  keywords = {Distribution,interaction,publish/subscribe},
  pages = {114--131},
  file = {Eugster et al. - 2003 - The Many Faces of PublishSubscribe.pdf:/home/moiri/Dropbox/papers/Eugster et al. - 2003 - The Many Faces of PublishSubscribe.pdf:application/pdf}
}

@article{obermaisser2006,
  title = {Reuse of {{CAN}}-{{Based Legacy Applications}} in {{Time}}-{{Triggered Architectures}}},
  volume = {2},
  issn = {1551-3203},
  doi = {10.1109/TII.2006.885920},
  abstract = {Upcoming car series will be deployed with time-triggered communication protocols due to benefits with respect to bandwidth, predictability, dependability, and system integration. In present day automotive networks, controller area network (CAN) is the most widely used communication protocol. Today, up to five CAN buses and several private CAN networks result from the bandwidth limits of CAN in conjunction with constraints concerning bus utilization aimed at controlling transmission latencies. In this context, the upcoming introduction of time-triggered networks into series production offers the potential to reduce the number of CAN networks by exploiting the high bandwidth of the time-triggered network instead of CAN buses. Due to the elimination of CAN buses, the resulting reduction of wiring and connectors promises a significant reduction in hardware cost and reliability improvements. In order to support the reuse of existing CAN-based application software, this paper presents a solution for the emulation of a CAN communication service on top of an underlying time-triggered network. By providing to CAN-based applications the same interface as in a conventional CAN system, redevelopment efforts for CAN-based legacy software are minimized. For this purpose, a CAN emulation middleware operates between a operating system and the CAN-based applications. In a first step, the middleware establishes event channels on top of the communication network in order to support on-demand transmission requests at a priori unknown points in time. The middleware then emulates the carrier sense multiple access collision avoidance (CSMA/CA) media access protocol of a physical CAN network for passing messages received via event channels to the application in the correct temporal order. Finally, the application programming interface (API) of the widely used HIS/VectorCAN driver provides a handle-based programming interface with support for message filtering and callbacks. A validation se- - tup with a time-triggered protocol (TTP) cluster demonstrates that the CAN emulation can handle CAN-based legacy software and a real-world communication matrix provided by the automotive industry},
  timestamp = {2015-02-04T17:46:57Z},
  number = {4},
  journal = {IEEE Transactions on Industrial Informatics},
  author = {Obermaisser, Roman},
  month = nov,
  year = {2006},
  keywords = {access protocols,application programming interface,Application software,automotive engineering,automotive networks,Bandwidth,CAN-based legacy applications,CAN buses,CAN emulation middleware,carrier sense multiple access collision avoidance,Communication system control,computer network performance,Context,controller area network,controller area networks,Delay,distributed algorithms,driver information systems,Emulation,HIS/VectorCAN driver,legacy systems,Media Access Protocol,middleware,operating system,Production,Protocols,real-time systems,realtime systems,road vehicle electronics,road vehicles,time-triggered communication protocols},
  pages = {255--268},
  file = {Obermaisser - 2006 - Reuse of CAN-Based Legacy Applications in Time-Triggered Architectures.pdf:/home/moiri/Dropbox/papers/Obermaisser - 2006 - Reuse of CAN-Based Legacy Applications in Time-Triggered Architectures.pdf:application/pdf}
}

@inproceedings{castrillon2015,
  address = {San Jose, CA, USA},
  series = {DATE '15},
  title = {Multi/{{Many}}-Core {{Programming}}: {{Where Are We Standing}}?},
  shorttitle = {Multi/{{Many}}-Core {{Programming}}},
  abstract = {This paper presents different views exposed in a special session on the current standing of programming and design tools for multi and manycores in the embedded domain. After approximately ten years of the advent of multicore architectures, we take a look at state-of-the-art and trends in model-based programming methodologies from an academic point of view. This view is contrasted with early experiences in transferring multicore compiler research to industry, and complemented with a critical view on the performance gap introduced by compilers for complex architectures. Today, multicores permeate new applications domains, creating new requirements and forcing researchers to rethink some underlying assumptions. This paper exposes the requirements of one such new domain, namely automotive. Applications in this domain require not only programming tools that comply to standards (e.g., ISO 26262) but also tools for high-level simulation, performance analysis and debugging. In this context, we discuss the role of virtual platforms in managing complexity of hardware-software interactions and accelerating the design of multicore systems for automotive applications.},
  timestamp = {2015-04-22T14:31:40Z},
  urldate = {2015-04-21},
  booktitle = {Proceedings of the 2015 {{Design}}, {{Automation}} \& {{Test}} in {{Europe Conference}} \& {{Exhibition}}},
  publisher = {{EDA Consortium}},
  author = {Castrillon, Jeronimo and Thiele, Lothar and Schorr, Lars and Sheng, Weihua and Juurlink, Ben and Alvarez-Mesa, Mauricio and Pohl, Angela and Jessenberger, Ralph and Reyes, Victor and Leupers, Rainer},
  year = {2015},
  pages = {1708--1717},
  file = {Castrillon et al. - 2015 - MultiMany-core Programming Where Are We Standing.pdf:/home/moiri/Dropbox/papers/Castrillon et al. - 2015 - MultiMany-core Programming Where Are We Standing.pdf:application/pdf}
}

@inproceedings{steiner2011,
  title = {Synthesis of {{Static Communication Schedules}} for {{Mixed}}-{{Criticality Systems}}},
  doi = {10.1109/ISORCW.2011.12},
  abstract = {Throughout many application areas of embedded and cyber-physical systems there is a demand to integrate more and more applications such that they share common resources. These applications may have different levels of criticality with respect to temporal or fault-tolerance properties and we call the result of their integration a mixed-criticality system. The communication network is a resource of particular importance and nowadays the system architecture is highly determined by a network's capabilities. A network for mixed-criticality systems has to establish partitioning such that the influence of messages from different applications on each other is bounded and the impact of low-critical messages on high-critical ones is minimized or removed at all. A straight forward way to establish network-wide partitioning is the time-triggered communication paradigm in which the communication schedule on the network is defined at design time and executed with respect to a globally synchronized time base. In this paper we discuss static scheduling methods for time-triggered traffic such that it can co-exist with non-time-triggered traffic. We introduce the concept of "schedule porosity'' and show the impact of time-triggered traffic on unsynchronized traffic as a function of schedule porosity.},
  timestamp = {2015-03-12T13:42:43Z},
  booktitle = {14th {{IEEE International Symposium}} on {{Object}}/{{Component}}/{{Service}}-{{Oriented Real}}-{{Time Distributed Computing Workshops}} ({{ISORCW}})},
  author = {Steiner, Wilfried},
  month = mar,
  year = {2011},
  keywords = {communication network,cyber-physical systems,embedded systems,fault-tolerance properties,fault tolerant computing,Jitter,Joining processes,local area networks,Memory management,mixed-criticality,Mixed-criticality systems,network,rate-constrained,Real-time,Receivers,resource allocation,resource sharing,schedule porosity,Schedules,SMT-solving,static communication schedule synthesis,telecommunication traffic,time-triggered,time-triggered communication paradigm,time-triggered traffic,Topology,Upper bound},
  pages = {11--18},
  file = {Steiner - 2011 - Synthesis of Static Communication Schedules for Mixed-Criticality Systems.pdf:/home/moiri/Dropbox/papers/Steiner - 2011 - Synthesis of Static Communication Schedules for Mixed-Criticality Systems.pdf:application/pdf}
}

@incollection{deAlfaro2005,
  series = {NATO Science Series},
  title = {Interface-{{Based Design}}},
  copyright = {\textcopyright{}2005 Springer},
  isbn = {978-1-4020-3530-2 978-1-4020-3532-6},
  abstract = {Surveying results from [5] and [6], we motivate and introduce the theory behind formalizing rich interfaces for software and hardware components. Rich interfaces specify the protocol aspects of component interaction. Their formalization, called interface automata, permits a compiler to check the compatibility of component interaction protocols. Interface automata support incremental design and independent implementability. Incremental design means that the compatibility checking of interfaces can proceed for partial system descriptions, without knowing the interfaces of all components. Independent implementability means that compatible interfaces can be refined separately, while still maintaining compatibility.},
  language = {english},
  timestamp = {2017-06-09T09:32:00Z},
  number = {195},
  urldate = {2016-10-18},
  booktitle = {Engineering {{Theories}} of {{Software Intensive Systems}}},
  publisher = {{Springer Netherlands}},
  author = {{de Alfaro}, Luca and Henzinger, Thomas A.},
  editor = {Broy, Manfred and Gr{\"u}nbauer, Johannes and Harel, David and Hoare, Tony},
  year = {2005},
  keywords = {component-based design,formal methods,Interface Automata,Models and Principles,Programming Languages; Compilers; Interpreters,Programming Techniques,Software engineering,Theory of Computation},
  pages = {83--104},
  file = {Alfaro and Henzinger - 2005 - Interface-Based Design.pdf:/home/moiri/Dropbox/papers/Alfaro and Henzinger - 2005 - Interface-Based Design.pdf:application/pdf},
  doi = {10.1007/1-4020-3532-2_3}
}

@techreport{derler2008,
  title = {{{PTIDES}}: {{A Programming Model}} for {{Distributed Real}}-{{Time Embedded Systems}}},
  abstract = {We describe a programming model called PTIDES (Programming Temporally Integrated Distributed Embedded Systems), that extends the discrete-event model of computation with a carefully chosen relationship between real time and model time. PTIDES provides a framework for exploring a family of execution strategies for distributed embedded systems. Our objective in this paper is to present an execution strategy that 1) allows independent events to be processed out of time stamp order, 2) uses clock synchronization as a replacement for null message communication across distributed platforms, 3) defines a notion of when events are safe to process and 4) presents an implementation of a PTIDES model. This work puts forward an execution strategy that is aggressive in concurrent execution of events.},
  timestamp = {2014-10-09T09:35:27Z},
  number = {UCB/EECS-2008-72},
  institution = {EECS Department, University of California, Berkeley},
  author = {Derler, Patricia and Feng, Thomas Huining and Lee, Edward A. and Matic, Slobodan and Patel, Hiren D. and Zhao, Yang and Zou, Jia},
  month = may,
  year = {2008},
  keywords = {PTIDES,real-time},
  file = {Derler et al. - 2008 - PTIDES A Programming Model for Distributed Real-Time Embedded Systems.pdf:/home/moiri/Dropbox/papers/Derler et al. - 2008 - PTIDES A Programming Model for Distributed Real-Time Embedded Systems.pdf:application/pdf}
}

@inproceedings{maurer2015,
  address = {Edinburgh, UK},
  series = {Advances in Parallel Computing},
  title = {Coordination with {{Structured Composition}} for {{Cyber}}-Physical {{Systems}}},
  volume = {27},
  isbn = {978-1-61499-620-0},
  doi = {10.3233/978-1-61499-621-7-615},
  language = {english},
  timestamp = {2017-06-09T09:34:25Z},
  urldate = {2016-01-12},
  booktitle = {Parallel {{Computing}}: {{On}} the {{Road}} to {{Exascale}}},
  publisher = {{IOS Press}},
  author = {Maurer, Simon and Kirner, Raimund},
  month = sep,
  year = {2015},
  pages = {615 -- 624},
  file = {Maurer and Kirner - 2015 - Coordination with Structured Composition for Cyber-physical Systems.pdf:/home/moiri/Dropbox/papers/Maurer and Kirner - 2015 - Coordination with Structured Composition for Cyber-physical Systems.pdf:application/pdf}
}

@article{bahmann2015,
  title = {Perfect {{Reconstructability}} of {{Control Flow}} from {{Demand Dependence Graphs}}},
  volume = {11},
  issn = {1544-3566},
  doi = {10.1145/2693261},
  abstract = {Demand-based dependence graphs (DDGs), such as the (Regionalized) Value State Dependence Graph ((R)VSDG), are intermediate representations (IRs) well suited for a wide range of program transformations. They explicitly model the flow of data and state, and only implicitly represent a restricted form of control flow. These features make DDGs especially suitable for automatic parallelization and vectorization, but cannot be leveraged by practical compilers without efficient construction and destruction algorithms. Construction algorithms remodel the arbitrarily complex control flow of a procedure to make it amenable to DDG representation, whereas destruction algorithms reestablish control flow for generating efficient object code. Existing literature presents solutions to both problems, but these impose structural constraints on the generatable control flow, and omit qualitative evaluation. The key contribution of this article is to show that there is no intrinsic structural limitation in the control flow directly extractable from RVSDGs. This fundamental result originates from an interpretation of loop repetition and decision predicates as computed continuations, leading to the introduction of the predicate continuation normal form. We provide an algorithm for constructing RVSDGs in predicate continuation form, and propose a novel destruction algorithm for RVSDGs in this form. Our destruction algorithm can generate arbitrarily complex control flow; we show this by proving that the original CFG an RVSDG was derived from can, apart from overspecific detail, be reconstructed perfectly. Additionally, we prove termination and correctness of these algorithms. Furthermore, we empirically evaluate the performance, the representational overhead at compile time, and the reduction in branch instructions compared to existing solutions. In contrast to previous work, our algorithms impose no additional overhead on the control flow of the produced object code. To our knowledge, this is the first scheme that allows the original control flow of a procedure to be recovered from a DDG representation.},
  timestamp = {2016-02-24T17:57:04Z},
  number = {4},
  urldate = {2016-02-24},
  journal = {ACM Trans. Archit. Code Optim.},
  author = {Bahmann, Helge and Reissmann, Nico and Jahre, Magnus and Meyer, Jan Christian},
  month = jan,
  year = {2015},
  keywords = {control flow,demand-dependence,Intermediate representations,value state dependence graph},
  pages = {66:1--66:25},
  file = {Bahmann et al. - 2015 - Perfect Reconstructability of Control Flow from Demand Dependence Graphs.pdf:/home/moiri/Dropbox/papers/Bahmann et al. - 2015 - Perfect Reconstructability of Control Flow from Demand Dependence Graphs.pdf:application/pdf}
}

@incollection{bartoletti2015,
  series = {Lecture Notes in Computer Science},
  title = {Compliance in {{Behavioural Contracts}}: {{A Brief Survey}}},
  copyright = {\textcopyright{}2015 Springer International Publishing Switzerland},
  isbn = {978-3-319-25526-2 978-3-319-25527-9},
  shorttitle = {Compliance in {{Behavioural Contracts}}},
  abstract = {Behavioural contracts are formal specifications of interaction protocols between two or more distributed services. Despite the heterogeneous nature of the formalisms for behavioural contracts that have appeared in the literature, most of them feature a notion of compliance, which characterises when two or more contracts lead to correct interactions between services respecting them. We discuss and compare a selection of these notions in four different models of contracts: $\backslash$($\backslash$tau $\backslash$)-less CCS, session types, interface automata, and contract automata.},
  language = {english},
  timestamp = {2017-06-09T09:32:41Z},
  number = {9465},
  urldate = {2015-12-15},
  booktitle = {Programming {{Languages}} with {{Applications}} to {{Biology}} and {{Security}}},
  publisher = {{Springer International Publishing}},
  author = {Bartoletti, Massimo and Cimoli, Tiziana and Zunino, Roberto},
  editor = {Bodei, Chiara and Ferrari, Gian-Luigi and Priami, Corrado},
  year = {2015},
  keywords = {Algorithm Analysis and Problem Complexity,Computer Communication Networks,Information Systems Applications (incl. Internet),Interface Automata,Logics and Meanings of Programs,Programming Techniques,Session Types,Software engineering},
  pages = {103--121},
  file = {Bartoletti et al. - 2015 - Compliance in Behavioural Contracts A Brief Survey.pdf:/home/moiri/Dropbox/papers/Bartoletti et al. - 2015 - Compliance in Behavioural Contracts A Brief Survey.pdf:application/pdf},
  doi = {10.1007/978-3-319-25527-9_9}
}

@article{eker2003,
  title = {Taming {{Heterogeneity}} - {{The Ptolemy Approach}}},
  volume = {91},
  issn = {0018-9219},
  doi = {10.1109/JPROC.2002.805829},
  abstract = {Modern embedded computing systems tend to be heterogeneous in the sense of being composed of subsystems with very different characteristics, which communicate and interact in a variety of ways-synchronous or asynchronous, buffered or unbuffered, etc. Obviously, when designing such systems, a modeling language needs to reflect this heterogeneity. Today's modeling environments usually offer a variant of what we call amorphous heterogeneity to address this problem. This paper argues that modeling systems in this manner leads to unexpected and hard-to-analyze interactions between the communication mechanisms and proposes a more structured approach to heterogeneity, called hierarchical heterogeneity, to solve this problem. It proposes a model structure and semantic framework that support this form of heterogeneity, and discusses the issues arising from heterogeneous component interaction and the desire for component reuse. It introduces the notion of domain polymorphism as a way to address these issues.},
  timestamp = {2015-05-22T15:41:02Z},
  number = {1},
  journal = {Proceedings of the IEEE},
  author = {Eker, Johan. and Janneck, Jorn W. and Lee, Edward A. and Liu, Jie and Liu, Xiaojun and Ludvig, Jozsef and Neuendorffer, Stephen and Sachs, Sonia and Xiong, Yuhong},
  month = jan,
  year = {2003},
  keywords = {Amorphous materials,component-based design,component reuse,Computational modeling,Design methodology,domain polymorphism,Electronic switching systems,Embedded computing,embedded computing systems,embedded software,embedded system,embedded systems,heterogeneous modeling,hierarchical heterogeneity,Microelectronics,modeling environments,models of computation,object-oriented programming,programming environments,Ptolemy,Ptolemy II,software architecture,software environment,software reusability,Software systems,Yarn},
  pages = {127--144},
  file = {Eker et al. - 2003 - Taming Heterogeneity - The Ptolemy Approach.pdf:/home/moiri/Dropbox/papers/Eker et al. - 2003 - Taming Heterogeneity - The Ptolemy Approach.pdf:application/pdf}
}

@article{yao2016,
  title = {{{MixCPS}}: {{Mixed Time}}/{{Event}}-{{Triggered Architecture}} of {{Cyber Physical Systems}}},
  volume = {PP},
  issn = {0018-9219},
  shorttitle = {{{MixCPS}}},
  doi = {10.1109/JPROC.2016.2519381},
  abstract = {Cyber\textendash{}physical system (CPS) integrates variety of applications where some work in a time-triggered manner while others work in an event-triggered manner. Supporting unified designs of both time-triggered and event-triggered tasks facilitates the integration of CPS applications. This paper presents a mixed time/event-triggered architecture called MixCPS to make CPS applications work in the integrated and optimized manner. To optimize MixCPS, we propose a new timing performance metric for CPS applications, i.e., the application-level delay, which is induced from sensor to actuator and captures the coupling between cyber and physical worlds. Using the system-level time-triggered scheduling based on the synchronization between computation and communication nodes, we optimize the assignment of computation tasks and the packet transmissions in order to minimize the application-level delays. Furthermore, we discuss the scheduling policy for event-trigged tasks after the resource reservation for time-trigged tasks. Finally, the proposed MixCPS is evaluated by several simulations which show that the application-level delays can be significantly reduced through the time-triggered cooperation mechanism of computation and communication.},
  timestamp = {2016-04-05T09:55:14Z},
  number = {99},
  journal = {Proceedings of the IEEE},
  author = {Yao, J. and Xu, X. and Liu, X.},
  year = {2016},
  keywords = {Application-level delay,Computer architecture,Couplings,cyber–physical systems (CPSs),Delays,event-triggered,Job shop scheduling,Protocols,real-time systems,time-triggered},
  pages = {1--15},
  file = {Yao et al. - 2016 - MixCPS Mixed TimeEvent-Triggered Architecture of Cyber Physical Systems.pdf:/home/moiri/Dropbox/papers/Yao et al. - 2016 - MixCPS Mixed TimeEvent-Triggered Architecture of Cyber Physical Systems.pdf:application/pdf}
}

@article{lee2003,
  title = {Actor-{{Oriented Design}} of {{Embedded Hardware}} and {{Software Systems}}},
  volume = {12},
  issn = {0218-1266},
  doi = {10.1142/S0218126603000751},
  abstract = {In this paper, we argue that model-based design and platform-based design are two views of the same thing. A platform is an abstraction layer in the design flow. For example, a core-based architecture and an instruction set architecture are platforms. We focus on the set of designs induced by this abstraction layer. For example, the set of all ASICs based on a particular core-based architecture and the set of all x86 programs are induced sets. Hence, a platform is equivalently a set of designs. Model-based design is about using platforms with useful modeling properties to specify designs, and then synthesizing implementations from these specifications. Hence model-based design is the view from above (more abstract, closer to the problem domain) and platform-based design is the view from below (less abstract, closer to the implementation technology). One way to define a platform is to provide a design language. Any valid expression in the language is an element of the set. A platform provides a set of constraints together with known tradeoffs that flow from those constraints. Actor-oriented platforms, such as Simulink, abstract aspects of program-level platforms, such as Java, C++, and VHDL. Actor-oriented platforms orthogonalize the actor definition language and the actor composition language, enabling highly polymorphic actor definitions and design using multiple models of computation. In particular, we concentrate on the use of constrained models of computation in design. The modeling properties implied by well chosen constraints allow more easily understood designs and are preserved during synthesis into program-level descriptions. We illustrate these concepts by describing a design framework built on Ptolemy II.},
  language = {english},
  timestamp = {2017-06-09T09:34:11Z},
  number = {03},
  urldate = {2014-11-07},
  journal = {J CIRCUIT SYST COMP},
  author = {Lee, Edward A. and Neuendorffer, Stephen and Wirthlin, Michael J.},
  month = jun,
  year = {2003},
  pages = {231--260},
  file = {Lee et al. - 2003 - Actor-Oriented Design of Embedded Hardware and Sof.pdf:/home/moiri/Dropbox/papers/Lee et al. - 2003 - Actor-Oriented Design of Embedded Hardware and Sof.pdf:application/pdf}
}

@incollection{larsen2006,
  series = {Lecture Notes in Computer Science},
  title = {Interface {{Input}}/{{Output Automata}}},
  copyright = {\textcopyright{}2006 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-37215-8 978-3-540-37216-5},
  abstract = {Building on the theory of interface automata by de Alfaro and Henzinger we design an interface language for Lynch's I/O, a popular formalism used in the development of distributed asynchronous systems, not addressed by previous interface research. We introduce an explicit separation of assumptions from guarantees not yet seen in other behavioral interface theories. Moreover we derive the composition operator systematically and formally, guaranteeing that the resulting compositions are always the weakest in the sense of assumptions, and the strongest in the sense of guarantees. We also present a method for solving systems of relativized behavioral inequalities as used in our setup and draw a formal correspondence between our work and interface automata.},
  language = {english},
  timestamp = {2017-06-09T09:34:01Z},
  number = {4085},
  urldate = {2016-10-14},
  booktitle = {{{FM}} 2006: {{Formal Methods}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Larsen, Kim G. and Nyman, Ulrik and W\k{a}sowski, Andrzej},
  editor = {Misra, Jayadev and Nipkow, Tobias and Sekerinski, Emil},
  month = aug,
  year = {2006},
  keywords = {Interface Automata,Logics and Meanings of Programs,Mathematical Logic and Formal Languages,Programming Languages; Compilers; Interpreters,Programming Techniques,Software engineering,Software Engineering/Programming and Operating Systems},
  pages = {82--97},
  file = {Larsen et al. - 2006 - Interface InputOutput Automata - BRICS report.pdf:/home/moiri/Dropbox/papers/Larsen et al. - 2006 - Interface InputOutput Automata - BRICS report.pdf:application/pdf;Larsen et al. - 2006 - Interface InputOutput Automata.pdf:/home/moiri/Dropbox/papers/Larsen et al. - 2006 - Interface InputOutput Automata.pdf:application/pdf},
  doi = {10.1007/11813040_7}
}

@incollection{rossi2001,
  title = {Tuple-Based {{Technologies}} for {{Coordination}}},
  copyright = {\textcopyright{}2001 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-642-07488-2 978-3-662-04401-8},
  abstract = {By tuple-based technologies we refer to any coordination system that uses associative access to shared dataspaces for communication / synchronization purposes. The idea of using a shared dataspace to coordinate concurrent activities first appeared in the Linda coordination language, which defined a coordination model based on the so-called tuple space, as well as a set of primitives, that extend a host computational language, to access it. The basic Linda model has been extended in various ways by different languages / architectures in order to deal with the different requirements of different application areas, from high speed parallel computations (the context in which Linda was designed) to Internet-based multi-agent architectures. This chapter surveys various tuple-based coordination systems and models, introducing a taxonomy (based on the enhancements with respect to the original Linda model) as well as a set of criteria to classify the considered projects. Our aim is not just to supply an updated reference to existing tuple-based coordination systems, but also to provide the reader with some helpful guidelines to compare coordination models and systems. Given the book focus, we will restrict our survey to the technologies that are explicitly targeted to open distributed systems, trying, at the same time, to offer a perspective that is as wide as possible.},
  language = {en},
  timestamp = {2014-10-08T09:25:45Z},
  urldate = {2014-10-01},
  booktitle = {Coordination of {{Internet Agents}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Rossi, Davide and Cabri, Giacomo and Denti, Enrico},
  editor = {Omicini, Andrea and Zambonelli, Franco and Klusch, Matthias and Tolksdorf, Robert},
  month = jan,
  year = {2001},
  keywords = {coordination language,survey},
  pages = {83--109},
  file = {Rossi et al. - 2001 - Tuple-based Technologies for Coordination.pdf:/home/moiri/Dropbox/papers/Rossi et al. - 2001 - Tuple-based Technologies for Coordination.pdf:application/pdf}
}

@techreport{grelck2013,
  title = {S-{{Net Language Report}}},
  timestamp = {2015-05-08T15:50:23Z},
  number = {2.1},
  urldate = {2015-05-08},
  institution = {version 2.0. Technical Report 499, University of Hertfordshire, School of Computer Science, Hatfield, AL10 9AB, United Kingdom},
  author = {Grelck, Clemens and Shafarenko, Alex},
  collaborator = {Penczek, Frank and Julku, Jukka and Cai, Haoxuan and H{\"o}lzenspies, Philip Kaj Ferdinand and Scholz, Sven-Bodo and Gijsbers, Bert},
  month = aug,
  year = {2013},
  file = {Grelck and Shafarenko - 2013 - S-Net Language Report.pdf:/home/moiri/Dropbox/papers/Grelck and Shafarenko - 2013 - S-Net Language Report.pdf:application/pdf}
}

@inproceedings{kirner2015,
  address = {K{\"a}rnten, Austria},
  title = {On the {{Specification}} of {{Real}}-Time {{Properties}} of {{Streaming Networks}}},
  abstract = {Cyper-physical systems (CPS) are networked embedded systems, having often real-time requirements for individual control tasks. The complexity of CPS due to concurrency can be reduced by modelling it as a streaming network, providing an implicit local synchronisation mechanism.
In this paper we show that specifying real-time requirements for such streaming networks is not straight forward. Especially specifying latency is challenging due to their global context from which they arise. Analysing models at requirements and system design level, we provide practical solutions to the specification of the timing behaviour of such models of streaming networks.},
  timestamp = {2015-10-30T17:38:17Z},
  booktitle = {18. {{Kolloquium Programmiersprachen}} und {{Grundlagen}} der {{Programmierung}}},
  author = {Kirner, Raimund and Maurer, Simon},
  month = oct,
  year = {2015},
  file = {Kirner and Maurer - 2015 - On the Specification of Real-time Properties of Streaming Networks.pdf:/home/moiri/Dropbox/papers/Kirner and Maurer - 2015 - On the Specification of Real-time Properties of Streaming Networks.pdf:application/pdf}
}

@incollection{larsen2007,
  series = {Lecture Notes in Computer Science},
  title = {Modal {{I}}/{{O Automata}} for {{Interface}} and {{Product Line Theories}}},
  copyright = {\textcopyright{}2007 Springer Berlin Heidelberg},
  isbn = {978-3-540-71314-2 978-3-540-71316-6},
  abstract = {Alfaro and Henzinger use alternating simulation in a two player game as a refinement for interface automata [1]. We show that interface automata correspond to a subset of modal transition systems of Larsen and Thomsen [2], on which alternating simulation coincides with modal refinement. As a consequence a more expressive interface theory may be built, by a simple generalization from interface automata to modal automata. We define modal I/O automata, an extension of interface automata with modality. Our interface theory that follows can express liveness properties, disallowing trivial implementations of interfaces, a problem that exists for theories build around simulation preorders. In order to further exemplify the usefulness of modal I/O automata, we construct a behavioral variability theory for product line development.},
  language = {english},
  timestamp = {2017-06-09T09:34:05Z},
  number = {4421},
  urldate = {2016-10-18},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Larsen, Kim G. and Nyman, Ulrik and W\k{a}sowski, Andrzej},
  editor = {Nicola, Rocco De},
  month = mar,
  year = {2007},
  keywords = {Data Structures,Interface Automata,Logics and Meanings of Programs,Programming Languages; Compilers; Interpreters,Programming Techniques,Software engineering,Software Engineering/Programming and Operating Systems},
  pages = {64--79},
  file = {Larsen et al. - 2007 - Modal IO Automata for Interface and Product Line Theories.pdf:/home/moiri/Dropbox/papers/Larsen et al. - 2007 - Modal IO Automata for Interface and Product Line Theories.pdf:application/pdf},
  doi = {10.1007/978-3-540-71316-6_6}
}

@article{gelernter1992,
  title = {Coordination {{Languages}} and {{Their Significance}}},
  volume = {35},
  issn = {0001-0782},
  doi = {10.1145/129630.129635},
  timestamp = {2014-10-02T12:27:42Z},
  number = {2},
  urldate = {2014-10-02},
  journal = {Commun. ACM},
  author = {Gelernter, David and Carriero, Nicholas},
  month = feb,
  year = {1992},
  keywords = {coordination languages,Linda},
  pages = {97--107},
  file = {Gelernter and Carriero - 1992 - Coordination Languages and Their Significance.pdf:/home/moiri/Dropbox/papers/Gelernter and Carriero - 1992 - Coordination Languages and Their Significance.pdf:application/pdf}
}

@incollection{thies2002,
  series = {Lecture Notes in Computer Science},
  title = {{{StreamIt}}: {{A Language}} for {{Streaming Applications}}},
  copyright = {\textcopyright{}2002 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-43369-9 978-3-540-45937-8},
  shorttitle = {{{StreamIt}}},
  abstract = {We characterize high-performance streaming applications as a new and distinct domain of programs that is becoming increasingly important. The StreamIt language provides novel high-level representations to improve programmer productivity and program robustness within the streaming domain. At the same time, the StreamIt compiler aims to improve the performance of streaming applications via stream-specific analyses and optimizations. In this paper, we motivate, describe and justify the language features of StreamIt, which include: a structured model of streams, a messaging system for control, a re-initialization mechanism, and a natural textual syntax.},
  language = {english},
  timestamp = {2017-06-09T09:34:50Z},
  number = {2304},
  urldate = {2014-09-29},
  booktitle = {Compiler {{Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Thies, William and Karczmarek, Michal and Amarasinghe, Saman},
  month = jan,
  year = {2002},
  keywords = {Artificial Intelligence (incl. Robotics),Logics and Meanings of Programs,Mathematical Logic and Formal Languages,Programming Languages; Compilers; Interpreters,Software engineering},
  pages = {179--196},
  file = {Thies et al. - 2002 - StreamIt A Language for Streaming Applications.pdf:/home/moiri/Dropbox/papers/Thies et al. - 2002 - StreamIt A Language for Streaming Applications.pdf:application/pdf}
}

@article{hennicker2015,
  title = {Moving from {{Interface Theories}} to {{Assembly Theories}}},
  volume = {52},
  issn = {0001-5903, 1432-0525},
  doi = {10.1007/s00236-015-0220-7},
  abstract = {We show how interface theories supporting pairwise component analysis can be extended in a generic way to a multi-component environment. This leads to the abstract framework of an assembly theory which captures notions of assembly refinement and communication-safety in assemblies of interacting components. An assembly theory supports also encapsulation of assemblies into interfaces and hence hierarchical constructions. We propose general rules that should be satisfied by any concrete assembly theory, like compositional construction and refinement of communication-safe assemblies. We discuss general procedures how to construct an assembly theory on top of a given interface theory such that (some of) the laws of an assembly theory are automatically guaranteed by the properties of an underlying interface theory. As a proof of concept we consider two instances of our approach. The first one starts from the (optimistic) interface theory of interface automata proposed by de Alfaro and Henzinger, and the second one from the (pessimistic) interface theory of modal I/O-interfaces. In the latter case, we propose a new notion of modal assembly refinement which has all the required properties, in particular it preserves modal communication-safety of assemblies. A small case-study illustrates how our concepts can be methodologically applied.},
  language = {english},
  timestamp = {2017-06-09T09:33:19Z},
  number = {2-3},
  urldate = {2016-10-18},
  journal = {Acta Informatica},
  author = {Hennicker, Rolf and Knapp, Alexander},
  month = mar,
  year = {2015},
  keywords = {Interface Automata},
  pages = {235--268},
  file = {Hennicker and Knapp - 2015 - Moving from Interface Theories to Assembly Theorie.pdf:/home/moiri/Dropbox/papers/Hennicker and Knapp - 2015 - Moving from Interface Theories to Assembly Theorie.pdf:application/pdf}
}

@incollection{dealfaro2002,
  series = {Lecture Notes in Computer Science},
  title = {Timed {{Interfaces}}},
  copyright = {\textcopyright{}2002 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-44307-0 978-3-540-45828-9},
  abstract = {We present a theory of timed interfaces, which is capable of specifying both the timing of the inputs a component expects from the environment, and the timing of the outputs it can produce. Two timed interfaces are compatible if there is a way to use them together such that their timing expectations are met. Our theory provides algorithms for checking the compatibility between two interfaces and for deriving the composite interface; the theory can thus be viewed as a type system for real-time interaction. Technically, a timed interface is encoded as a timed game between two players, representing the inputs and outputs of the component. The algorithms for compatibility checking and interface composition are thus derived from algorithms for solving timed games.},
  language = {en},
  timestamp = {2016-10-18T17:37:05Z},
  number = {2491},
  urldate = {2016-10-18},
  booktitle = {Embedded {{Software}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {{de Alfaro}, Luca and Henzinger, Thomas A. and Stoelinga, Mari{\"e}lle},
  editor = {Sangiovanni-Vincentelli, Alberto and Sifakis, Joseph},
  month = oct,
  year = {2002},
  keywords = {Computer Applications,Logics and Meanings of Programs,Operating Systems,Software Engineering/Programming and Operating Systems,Special Purpose and Application-Based Systems},
  pages = {108--122},
  file = {Alfaro et al. - 2002 - Timed Interfaces.pdf:/home/moiri/Dropbox/papers/Alfaro et al. - 2002 - Timed Interfaces.pdf:application/pdf},
  doi = {10.1007/3-540-45828-X_9}
}

@article{arbab1993,
  title = {An {{Overview}} of {{Manifold}} and {{Its Implementation}}},
  volume = {5},
  issn = {1040-3108},
  doi = {10.1002/cpe.4330050103},
  timestamp = {2014-11-05T16:39:13Z},
  number = {1},
  urldate = {2014-11-05},
  journal = {Concurrency: Pract. Exper.},
  author = {Arbab, Farhad. and Herman, Ivan and Spilling, Per},
  month = feb,
  year = {1993},
  pages = {23--70},
  file = {Arbab et al. - 1993 - An Overview of Manifold and Its Implementation.pdf:/home/moiri/Dropbox/papers/Arbab et al. - 1993 - An Overview of Manifold and Its Implementation.pdf:application/pdf}
}

@article{burns2016,
  title = {Mixed {{Criticality Systems}}: {{A Review}}},
  timestamp = {2017-08-18T18:14:26Z},
  journal = {Department of Computer Science, University of York, Tech. Rep},
  author = {Burns, Alan and Davis, Rob},
  month = dec,
  year = {2016},
  file = {Burns and Davis - 2016 - Mixed Criticality Systems A Review.pdf:/home/moiri/Dropbox/papers/Burns and Davis - 2016 - Mixed Criticality Systems A Review.pdf:application/pdf}
}

@inproceedings{lee2008,
  title = {Cyber {{Physical Systems}}: {{Design Challenges}}},
  isbn = {978-0-7695-3132-8},
  shorttitle = {Cyber {{Physical Systems}}},
  doi = {10.1109/ISORC.2008.25},
  abstract = {Cyber-Physical Systems (CPS) are integrations of computation and physical processes. Embedded computers and networks monitor and control the physical processes, usually with feedback loops where physical processes affect computations and vice versa. The economic and societal potential of such systems is vastly greater than what has been realized, and major investments are being made worldwide to develop the technology. There are considerable challenges, particularly because the physical components of such systems introduce safety and reliability requirements qualitatively different from those in general- purpose computing. Moreover, physical components are qualitatively different from object-oriented software components. Standard abstractions based on method calls and threads do not work. This paper examines the challenges in designing such systems, and in particular raises the question of whether today's computing and networking technologies provide an adequate foundation for CPS. It concludes that it will not be sufficient to improve design processes, raise the level of abstraction, or verify (formally or otherwise) designs that are built on today's abstractions. To realize the full potential of CPS, we will have to rebuild computing and networking abstractions. These abstractions will have to embrace physical dynamics and computation in a unified way.},
  timestamp = {2015-03-23T20:21:33Z},
  urldate = {2014-09-29},
  booktitle = {2008 11th {{IEEE International Symposium}} on {{Object Oriented Real}}-{{Time Distributed Computing}} ({{ISORC}})},
  publisher = {{IEEE}},
  author = {Lee, Edward A.},
  month = may,
  year = {2008},
  keywords = {Computerized monitoring,Computer networks,CPS,cyber-physical systems,Embedded computing,embedded systems,Feedback loop,feedback loops,Investments,object-oriented software,Physics computing,Process control,real time,Safety,Software quality,systems analysis,Yarn},
  pages = {363--369},
  file = {Lee - 2008 - Cyber Physical Systems Design Challenges.pdf:/home/moiri/Dropbox/papers/Lee - 2008 - Cyber Physical Systems Design Challenges.pdf:application/pdf}
}

@article{lee1999,
  title = {Modeling {{Concurrent Real}}-{{Time Processes Using Discrete Events}}},
  volume = {7},
  issn = {1022-7091, 1573-7489},
  doi = {10.1023/A:1018998524196},
  abstract = {We give a formal framework for studying real-time discrete-event systems. It describes concurrent processes as sets of possible behaviors. Compositions of processes are processes with behaviors in the intersection of the behaviors of the component processes. The interaction between processes is through signals, which are collections of events. Each event is a value-tag pair, where the tags denote time. Zeno conditions are defined and methods are given for avoiding them. Strict causality ensures determinacy under certain technical conditions, and delta-causality ensures the absence of Zeno conditions.},
  language = {en},
  timestamp = {2017-08-18T20:50:50Z},
  number = {1-4},
  urldate = {2014-11-07},
  journal = {Annals of Software Engineering},
  author = {Lee, Edward A.},
  month = oct,
  year = {1999},
  keywords = {discrete-event model,Discrete event systems,Software Engineering/Programming and Operating Systems},
  pages = {25--45},
  file = {Lee - 1999 - Modeling Concurrent Real-Time Processes Using Discrete Events.pdf:/home/moiri/Dropbox/papers/Lee - 1999 - Modeling Concurrent Real-Time Processes Using Discrete Events.pdf:application/pdf}
}

@article{lee1987,
  title = {Synchronous {{Data Flow}}},
  volume = {75},
  issn = {0018-9219},
  doi = {10.1109/PROC.1987.13876},
  abstract = {Data flow is a natural paradigm for describing DSP applications for concurrent implementation on parallel hardware. Data flow programs for signal processing are directed graphs where each node represents a function and each arc represents a signal path. Synchronous data flow (SDF) is a special case of data flow (either atomic or large grain) in which the number of data samples produced or consumed by each node on each invocation is specified a priori. Nodes can be scheduled statically (at compile time) onto single or parallel programmable processors so the run-time overhead usually associated with data flow evaporates. Multiple sample rates within the same system are easily and naturally handled. Conditions for correctness of SDF graph are explained and scheduling algorithms are described for homogeneous parallel processors sharing memory. A preliminary SDF software system for automatically generating assembly language code for DSP microcomputers is described. Two new efficiency techniques are introduced, static buffering and an extension to SDF to efficiently implement conditionals.},
  timestamp = {2017-08-18T21:10:29Z},
  number = {9},
  journal = {Proceedings of the IEEE},
  author = {Lee, Edward A. and Messerschmitt, David G.},
  month = sep,
  year = {1987},
  keywords = {Assembly systems,Digital signal processing,Flow graphs,Hardware,Microcomputers,Processor scheduling,Runtime,Scheduling algorithm,Signal processing,Software systems},
  pages = {1235--1245},
  file = {Lee and Messerschmitt - 1987 - Synchronous data flow.pdf:/home/moiri/Dropbox/papers/Lee and Messerschmitt - 1987 - Synchronous data flow.pdf:application/pdf}
}

@misc{open-mpi,
  title = {Open {{MPI}}: {{Open Source High Performance Computing}}},
  language = {english},
  timestamp = {2017-06-09T09:27:50Z},
  urldate = {2016-12-17},
  howpublished = {\url{https://www.open-mpi.org/}}
}

@inproceedings{honda2008,
  address = {New York, NY, USA},
  series = {POPL '08},
  title = {Multiparty {{Asynchronous Session Types}}},
  isbn = {978-1-59593-689-9},
  doi = {10.1145/1328438.1328472},
  abstract = {Communication is becoming one of the central elements in software development. As a potential typed foundation for structured communication-centred programming, session types have been studied over the last decade for a wide range of process calculi and programming languages, focussing on binary (two-party) sessions. This work extends the foregoing theories of binary session types to multiparty, asynchronous sessions, which often arise in practical communication-centred applications. Presented as a typed calculus for mobile processes, the theory introduces a new notion of types in which interactions involving multiple peers are directly abstracted as a global scenario. Global types retain a friendly type syntax of binary session types while capturing complex causal chains of multiparty asynchronous interactions. A global type plays the role of a shared agreement among communication peers, and is used as a basis of efficient type checking through its projection onto individual peers. The fundamental properties of the session type discipline such as communication safety, progress and session fidelity are established for generaln-party asynchronous interactions.},
  language = {english},
  timestamp = {2017-06-09T09:33:43Z},
  urldate = {2016-12-17},
  booktitle = {Proceedings of the 35th {{Annual ACM SIGPLAN}}-{{SIGACT Symposium}} on {{Principles}} of {{Programming Languages}}},
  publisher = {{ACM}},
  author = {Honda, Kohei and Yoshida, Nobuko and Carbone, Marco},
  year = {2008},
  keywords = {causality,choreography,communications,mobile processes,multiparty,session types,structured programming},
  pages = {273--284},
  file = {Honda et al. - 2008 - Multiparty Asynchronous Session Types.pdf:/home/moiri/Dropbox/papers/Honda et al. - 2008 - Multiparty Asynchronous Session Types.pdf:application/pdf}
}

@article{coffman1971,
  title = {System {{Deadlocks}}},
  volume = {3},
  issn = {0360-0300},
  doi = {10.1145/356586.356588},
  abstract = {A problem of increasing importance in the design of large multiprogramming systems is the, so-called, deadlock or deadly-embrace problem. In this article we survey the work that has been done on the treatment of deadlocks from both the theoretical and practical points of view.},
  language = {english},
  timestamp = {2017-06-09T09:33:01Z},
  number = {2},
  urldate = {2017-02-26},
  journal = {ACM Comput. Surv.},
  author = {Coffman, Edward. G. and Elphick, M. J. and Shoshani, Arie},
  month = jun,
  year = {1971},
  pages = {67--78},
  file = {Coffman et al. - 1971 - System Deadlocks.pdf:/home/moiri/Dropbox/papers/Coffman et al. - 1971 - System Deadlocks.pdf:application/pdf}
}

@inproceedings{kroening2016,
  title = {Sound {{Static Deadlock Analysis}} for {{C}}/{{Pthreads}}},
  abstract = {We present a static deadlock analysis for C/Pthreads. The design of our method has been guided by the requirement to analyse real-world code. Our approach is sound (i.e., misses no deadlocks) for programs that have defined behaviour according to the C standard and the Pthreads specification, and is precise enough to prove deadlock-freedom for a large number of such programs. The method consists of a pipeline of several analyses that build on a new context- and thread-sensitive abstract interpretation framework. We further present a lightweight dependency analysis to identify statements relevant to deadlock analysis and thus speed up the overall analysis. In our experimental evaluation, we succeeded to prove deadlock-freedom for 292 programs from the Debian GNU/Linux distribution with in total 2.3 MLOC in 4 hours.},
  language = {english},
  timestamp = {2017-06-09T09:33:58Z},
  booktitle = {2016 31st {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}} ({{ASE}})},
  author = {Kroening, Daniel and Poetzl, Daniel and Schrammel, Peter and Wachter, Bj\"orn},
  month = sep,
  year = {2016},
  keywords = {abstract interpretation,C language,Computer bugs,Concurrent computing,context-sensitive abstract interpretation framework,C/Pthreads,C standard,deadlock analysis,deadlock-freedom,Debian GNU/Linux distribution,formal specification,Instruction sets,lightweight dependency analysis,Linux,Pipelines,program diagnostics,Pthreads specification,real-world code analysis,Scalability,sound static deadlock analysis,Standards,static analysis,System recovery,thread-sensitive abstract interpretation framework,time 4 hour},
  pages = {379--390},
  file = {Kroening et al. - 2016 - Sound Static Deadlock Analysis for CPthreads (extended).pdf:/home/moiri/Dropbox/papers/Kroening et al. - 2016 - Sound Static Deadlock Analysis for CPthreads (extended).pdf:application/pdf;Kroening et al. - 2016 - Sound Static Deadlock Analysis for CPthreads.pdf:/home/moiri/Dropbox/papers/Kroening et al. - 2016 - Sound Static Deadlock Analysis for CPthreads.pdf:application/pdf}
}

@article{johnson1975,
  title = {Finding {{All}} the {{Elementary Circuits}} of a {{Directed Graph}}},
  volume = {4},
  issn = {0097-5397},
  doi = {10.1137/0204007},
  abstract = {An algorithm is presented which finds all the elementary circuits of a directed graph in time bounded by \$O((n + e)(c + 1))\$ and space bounded by \$O(n + e)\$, where there are n vertices, e edges and c elementary circuits in the graph. The algorithm resembles algorithms by Tiernan and Tarjan, but is faster because it considers each edge at most twice between any one circuit and the next in the output sequence.},
  language = {english},
  timestamp = {2017-06-09T09:33:50Z},
  number = {1},
  urldate = {2017-05-05},
  journal = {SIAM J. Comput.},
  author = {Johnson, Donald B.},
  month = mar,
  year = {1975},
  pages = {77--84},
  file = {Johnson - 1975 - Finding All the Elementary Circuits of a Directed .PDF:/home/moiri/Dropbox/papers/Johnson - 1975 - Finding All the Elementary Circuits of a Directed .PDF:application/pdf}
}

@article{tarjan1972,
  title = {Depth-{{First Search}} and {{Linear Graph Algorithms}}},
  volume = {1},
  issn = {0097-5397},
  doi = {10.1137/0201010},
  abstract = {The value of depth-first search or ``backtracking'' as a technique for solving problems is illustrated by two examples. An improved version of an algorithm for finding the strongly connected components of a directed graph and at algorithm for finding the biconnected components of an undirect graph are presented. The space and time requirements of both algorithms are bounded by \$k\_1 V + k\_2 E + k\_3 \$ for some constants \$k\_1 ,k\_2 \$, and \$k\_3 \$, where V is the number of vertices and E is the number of edges of the graph being examined.},
  language = {english},
  timestamp = {2017-06-09T09:34:46Z},
  number = {2},
  urldate = {2017-05-05},
  journal = {SIAM J. Comput.},
  author = {Tarjan, Robert},
  month = jun,
  year = {1972},
  pages = {146--160},
  file = {Tarjan - 1972 - Depth-First Search and Linear Graph Algorithms.pdf:/home/moiri/Dropbox/papers/Tarjan - 1972 - Depth-First Search and Linear Graph Algorithms.pdf:application/pdf}
}

@inproceedings{rajkumar2010,
  title = {Cyber-Physical {{Systems}}: {{The Next Computing Revolution}}},
  shorttitle = {Cyber-Physical Systems},
  doi = {10.1145/1837274.1837461},
  abstract = {Cyber-physical systems (CPS) are physical and engineered systems whose operations are monitored, coordinated, controlled and integrated by a computing and communication core. Just as the internet transformed how humans interact with one another, cyber-physical systems will transform how we interact with the physical world around us. Many grand challenges await in the economically vital domains of transportation, health-care, manufacturing, agriculture, energy, defense, aerospace and buildings. The design, construction and verification of cyber-physical systems pose a multitude of technical challenges that must be addressed by a cross-disciplinary community of researchers and educators.},
  timestamp = {2017-05-12T14:21:17Z},
  booktitle = {Design {{Automation Conference}}},
  author = {Rajkumar, Ragunathan and Lee, Insup and Sha, Lui and Stankovic, John},
  month = jun,
  year = {2010},
  keywords = {Communication system control,Computer science,Control systems,cross-disciplinary community,cyber physical system,cyber-physical systems,engineering,grand challenges,healthcare,human interaction,Humans,Internet,Manufacturing,Monitoring,new frontiers,next computing revolution,Physics computing,power engineering computing,Power generation economics,power grids,social aspects of automation,Systems engineering and theory,Transportation,user interfaces},
  pages = {731--736},
  file = {Rajkumar et al. - 2010 - Cyber-physical Systems The Next Computing Revolut.pdf:/home/moiri/Dropbox/papers/Rajkumar et al. - 2010 - Cyber-physical Systems The Next Computing Revolut.pdf:application/pdf}
}

@inproceedings{pollack1999,
  address = {Washington, DC, USA},
  series = {MICRO 32},
  title = {New {{Microarchitecture Challenges}} in the {{Coming Generations}} of {{CMOS Process Technologies}} ({{Keynote Address}})},
  isbn = {978-0-7695-0437-7},
  abstract = {Over the last 15 years, CMOS scaling simplified the task of the microprocessor architect. With each new process technology, frequency increased by -50\%, and transistor density increase by 100 percent. Also, the improvements in manufacturing technology (larger wafers and higher yields) allowed for increasing die sizes without increasing cost. Projections of die sizes of 1 square inch or higher were common.
However, the end of these easy times is in sight, and several new challenges are facing the architect. Die size is no longer going to be limited by equipment or manufacturing cost, but rather by power. To date the approach has been to lower voltage with each process generation. But as voltage is lowered, leakage current and energy increase, contributing to higher power. And the problems extend beyond power dissipation to power delivery/distribution and increasing power density.
This talk will first look at the historical trends of CMOS process technology in the context of past microprocessors. It will then look at the implications of continued CMOS scaling, as described above, and the new challenges they pose. Microarchitecture techniques that have exacerbated the power problem will also be covered. Finally, the talk will describe some of the microarchitecture directions that may lead to more power-efficient and cost-efficient microprocessors.},
  timestamp = {2017-05-13T10:52:39Z},
  urldate = {2017-05-13},
  booktitle = {Proceedings of the {{32Nd Annual ACM}}/{{IEEE International Symposium}} on {{Microarchitecture}}},
  publisher = {{IEEE Computer Society}},
  author = {Pollack, Fred J.},
  year = {1999},
  pages = {2--},
  file = {Pollack - 1999 - New Microarchitecture Challenges in the Coming Generations of CMOS Technologies (Abstract).pdf:/home/moiri/Dropbox/papers/Pollack - 1999 - New Microarchitecture Challenges in the Coming Generations of CMOS Technologies (Abstract).pdf:application/pdf;Pollack - 1999 - New Microarchitecture Challenges in the Coming Generations of CMOS Technologies (Slides).pdf:/home/moiri/Dropbox/papers/Pollack - 1999 - New Microarchitecture Challenges in the Coming Generations of CMOS Technologies (Slides).pdf:application/pdf}
}

@phdthesis{agha1985,
  address = {Massachusetts, US},
  type = {PhD},
  title = {{{ACTORS}}: {{A Model}} of {{Concurrent Computation}} in {{Distributed Systems}}},
  shorttitle = {{{ACTORS}}},
  abstract = {A foundational model of concurrency is  developed in this thesis. We examine issues  in the design of parallel systems and show  why the actor model is suitable for exploiting  large-scale parallelism. Concurrency in actors  is constrained only by the availability of  hardware resources and by the logical  dependence inherent in the computation.  Unlike dataflow and functional programming,  however, actors are dynamically  reconfigurable and can model shared  resources with changing local state.  Concurrency is spawned in actors using  asynchronous message-passing, pipelining,  and the dynamic creation of actors. This  thesis deals with some central issues in  distributed computing. Specifically, problems  of divergence and deadlock are addressed.  For example, actors permit dynamic deadlock  detection and removal. The problem of  divergence is contained because  independent transactions can execute  concurrently and potentially infinite processes  are nevertheless available for interaction.},
  language = {en\_US},
  timestamp = {2017-05-13T14:33:24Z},
  urldate = {2017-05-13},
  school = {MIT},
  author = {Agha, Gul Abdulnabi},
  month = jun,
  year = {1985},
  file = {Agha - 1985 - ACTORS A Model of Concurrent Computation in Distr.pdf:/home/moiri/Dropbox/papers/Agha - 1985 - ACTORS A Model of Concurrent Computation in Distr.pdf:application/pdf}
}

@book{roscoe1997,
  address = {Upper Saddle River, NJ, USA},
  title = {The {{Theory}} and {{Practice}} of {{Concurrency}}},
  isbn = {978-0-13-674409-2},
  abstract = {From the Publisher:Since the introduction of Hoares' Communicating Sequential Processes notation, powerful new tools have transformed CSP into a practical way of describing industrial-sized problems. This book gives you the fundamental grasp of CSP concepts you'll need to take advantage of those tools.Part I provides a detailed foundation for working with CSP, using as little mathematics as possible. It introduces the ideas behind operational, denotational and algebraic models of CSP. Parts II and III go into greater detail about theory and practice. Topics include: parallel operators, hiding and renaming, piping and enslavement, buffers and communication, termination and sequencing, and semantic theory. Three detailed practical case studies are also presented.For anyone interested in modeling sequential processes.},
  language = {english},
  timestamp = {2017-06-09T09:34:37Z},
  publisher = {{Prentice Hall PTR}},
  author = {Roscoe, Bill},
  year = {1997},
  file = {The.Theory.and.Practice.of.Concurrency_Roscoe.pdf:/home/moiri/Dropbox/books/The.Theory.and.Practice.of.Concurrency_Roscoe.pdf:application/pdf}
}

@inproceedings{basu2006,
  title = {Modeling {{Heterogeneous Real}}-Time {{Components}} in {{BIP}}},
  doi = {10.1109/SEFM.2006.27},
  abstract = {We present a methodology for modeling heterogeneous real-time components. Components are obtained as the superposition of three layers: behavior, specified as a set of transitions; Interactions between transitions of the behavior; Priorities, used to choose amongst possible interactions. A parameterized binary composition operator is used to compose components layer by layer. We present the BIP language for the description and composition of layered components as well as associated tools for executing and analyzing components on a dedicated platform. The language provides a powerful mechanism for structuring interactions involving rendezvous and broadcast. We show that synchronous and timed systems are particular classes of components. Finally, we provide examples and compare the BIP framework to existing ones for heterogeneous component-based modeling},
  language = {english},
  timestamp = {2017-06-09T09:32:45Z},
  booktitle = {Fourth {{IEEE International Conference}} on {{Software Engineering}} and {{Formal Methods}} ({{SEFM}}'06)},
  author = {Basu, Ananda and Bozga, Marius and Sifakis, Joseph},
  month = sep,
  year = {2006},
  keywords = {Application software,Assembly systems,behavior interaction priority layer,BIP language,Broadcasting,Clocks,Connectors,heterogeneous real-time components,object-oriented programming,parameterized binary composition operator,Power engineering and energy,Power system modeling,Software standards,Synchronization,systems analysis,systems engineering,Systems engineering and theory},
  pages = {3--12},
  file = {Basu et al. - 2006 - Modeling Heterogeneous Real-time Components in BIP.pdf:/home/moiri/Dropbox/papers/Basu et al. - 2006 - Modeling Heterogeneous Real-time Components in BIP.pdf:application/pdf}
}

@article{bliudze2008,
  title = {The {{Algebra}} of {{Connectors}}  - {{Structuring Interaction}} in {{BIP}}},
  volume = {57},
  issn = {0018-9340},
  doi = {10.1109/TC.2008.26},
  abstract = {We provide an algebraic formalization of connectors in the BIP component framework. A connector relates a set of typed ports. Types are used to describe different modes of synchronization: rendezvous and broadcast, in particular. Connectors on a set of ports P are modeled as terms of the algebra AC(P), generated from P by using a binary fusion operator and a unary typing operator. Typing associates with terms (ports or connectors) synchronization types \textemdash{} trigger or synchron \textemdash{} that determine modes of synchronization. Broadcast interactions are initiated by triggers. Rendezvous is a maximal interaction of a connector including only synchrons. The semantics of AC(P) associates with a connector the set of its interactions. It induces on connectors an equivalence relation which is not a congruence as it is not stable for fusion. We provide a number of properties of AC(P) used to symbolically simplify and handle connectors. We provide examples illustrating applications of AC(P), including a general component model encompassing synchrony, methods for incremental model decomposition, and efficient implementation by using symbolic techniques.},
  timestamp = {2017-05-25T17:31:11Z},
  number = {10},
  journal = {IEEE Transactions on Computers},
  author = {Bliudze, Simon and Sifakis, Joseph},
  month = oct,
  year = {2008},
  keywords = {algebra,algebraic formalization,Architecture,Assembly systems,behavior-interaction-priority,binary fusion operator,BIP component framework,Broadcasting,component model,Connectors,Controllability,embedded system,Fusion power generation,Insulation,integration and modeling,Interconnections (Subsystems),message passing,object-oriented programming,Real-time and embedded systems,System architectures,Systems engineering and theory,Systems specification methodology,unary typing operator},
  pages = {1315--1330},
  file = {Bliudze and Sifakis - 2008 - The Algebra of Connectors  - Structuring Interacti.pdf:/home/moiri/Dropbox/papers/Bliudze and Sifakis - 2008 - The Algebra of Connectors  - Structuring Interacti.pdf:application/pdf}
}

@inproceedings{gossler2002,
  title = {Composition for {{Component}}-{{Based Modeling}}},
  doi = {10.1007/978-3-540-39656-7_19},
  abstract = {Component-based engineering is of paramount importance for rigorous system design methodologies. It is founded on a paradigm which is common to all engineering disciplines: complex systems can be obtained by assembling components (building blocks). Components are usually characterized by abstractions that ignore implementation details and describe properties relevant to their composition e.g. transfer functions, interfaces. Composition is used to build complex components from simpler ones. It can be formalized as an operation that takes in components and their integration constraints. From these, it provides the description of a new, more complex component.},
  language = {english},
  timestamp = {2017-06-09T09:33:09Z},
  urldate = {2017-05-26},
  booktitle = {Formal {{Methods}} for {{Components}} and {{Objects}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {G{\"o}ssler, Gregor and Sifakis, Joseph},
  month = nov,
  year = {2002},
  keywords = {BIP},
  pages = {443--466},
  file = {Gössler and Sifakis - 2002 - Composition for Component-Based Modeling.pdf:/home/moiri/Dropbox/papers/Gössler and Sifakis - 2002 - Composition for Component-Based Modeling.pdf:application/pdf}
}

@inproceedings{henzinger2006,
  title = {The {{Embedded Systems Design Challenge}}},
  doi = {10.1007/11813040_1},
  abstract = {We summarize some current trends in embedded systems design and point out some of their characteristics, such as the chasm between analytical and computational models, and the gap between safety-critical and best-effort engineering practices. We call for a coherent scientific foundation for embedded systems design, and we discuss a few key demands on such a foundation: the need for encompassing several manifestations of heterogeneity, and the need for constructivity in design. We believe that the development of a satisfactory Embedded Systems Design Science provides a timely challenge and opportunity for reinvigorating computer science.},
  language = {en},
  timestamp = {2017-05-27T10:24:27Z},
  urldate = {2017-05-27},
  booktitle = {{{FM}} 2006: {{Formal Methods}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Henzinger, Thomas A. and Sifakis, Joseph},
  month = aug,
  year = {2006},
  pages = {1--15},
  file = {Henzinger and Sifakis - 2006 - The Embedded Systems Design Challenge.pdf:/home/moiri/Dropbox/papers/Henzinger and Sifakis - 2006 - The Embedded Systems Design Challenge.pdf:application/pdf}
}

@inproceedings{abdellatif2010,
  address = {New York, NY, USA},
  series = {EMSOFT '10},
  title = {Model-Based {{Implementation}} of {{Real}}-Time {{Applications}}},
  isbn = {978-1-60558-904-6},
  doi = {10.1145/1879021.1879052},
  abstract = {Correct and efficient implementation of general real-time applications remains by far an open problem. A key issue is meeting timing constraints whose satisfaction depends on features of the execution platform, in particular its speed. Existing rigorous implementation techniques are applicable to specific classes of systems e.g. with periodic tasks, time deterministic systems. We present a general model-based implementation method for real-time systems based on the use of two models. An abstract model representing the behavior of real-time software as a timed automaton. The latter describes user-defined platform-independent timing constraints. Its transitions are timeless and correspond to the execution of statements of the real-time software. A physical model representing the behavior of the real-time software running on a given platform. It is obtained by assigning execution times to the transitions of the abstract model. A necessary condition for implementability is time-safety, that is, any (timed) execution sequence of the physical model is also an execution sequence of the abstract model. Time-safety simply means that the platform is fast enough to meet the timing requirements. As execution times of actions are not known exactly, time-safety is checked for worst-case execution times of actions by making an assumption of time-robustness: time-safety is preserved when speed of the execution platform increases. We show that as a rule, physical models are not time-robust and show that time-determinism is a sufficient condition for time-robustness. For given real-time software and execution platform corresponding to a time-robust model, we define an Execution Engine that coordinates the execution of the application software so as to meet its timing constraints. Furthermore, in case of non-robustness, the Execution Engine can detect violations of time-safety and stop execution. We have implemented the Execution Engine for BIP programs with real-time constraints. We have validated the implementation method for an adaptive MPEG video encoder. Experimental results reveal the existence of timing anomalies seriously degrading performance for increasing platform execution speed.},
  timestamp = {2017-05-29T12:45:06Z},
  urldate = {2017-05-29},
  booktitle = {Proceedings of the {{Tenth ACM International Conference}} on {{Embedded Software}}},
  publisher = {{ACM}},
  author = {Abdellatif, Tesnim and Combaz, Jacques and Sifakis, Joseph},
  year = {2010},
  keywords = {BIP,Components,logical execution time,Real-time,timed automata},
  pages = {229--238},
  file = {Abdellatif et al. - 2010 - Model-based Implementation of Real-time Applicatio.pdf:/home/moiri/Dropbox/papers/Abdellatif et al. - 2010 - Model-based Implementation of Real-time Applicatio.pdf:application/pdf;Abdellatif et al. - 2010 - Model-based Implementation of Real-time Applications_Report.pdf:/home/moiri/Dropbox/papers/Abdellatif et al. - 2010 - Model-based Implementation of Real-time Applications_Report.pdf:application/pdf}
}

@inproceedings{pace2003,
  title = {Calculating $\tau$-{{Confluence Compositionally}}},
  doi = {10.1007/978-3-540-45069-6_41},
  abstract = {$\tau$-confluence is a reduction technique used in enumerative model-checking of labeled transition systems to avoid the state explosion problem. In this paper, we propose a new on-the-fly algorithm to calculate partial $\tau$-confluence, and propose new techniques to do so on large systems in a compositional manner. Using information inherent in the way a large system is composed of smaller systems, we show how we can deduce partial $\tau$-confluence in a computationally cheap manner. Finally, these techniques are applied to a number of case studies, including the rel/REL atomic multicast protocol.},
  language = {english},
  timestamp = {2017-06-09T09:34:28Z},
  urldate = {2017-05-30},
  booktitle = {Computer {{Aided Verification}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Pace, Gordon J. and Lang, Fr{\'e}d{\'e}ric and Mateescu, Radu},
  month = jul,
  year = {2003},
  pages = {446--459},
  file = {Pace et al. - 2003 - Calculating τ-Confluence Compositionally.pdf:/home/moiri/Dropbox/papers/Pace et al. - 2003 - Calculating τ-Confluence Compositionally.pdf:application/pdf}
}

@inproceedings{poplavko2015,
  title = {Models for {{Deterministic Execution}} of {{Real}}-Time {{Multiprocessor Applications}}},
  doi = {10.7873/DATE.2015.0302},
  abstract = {With the proliferation of multi-cores in embedded real-time systems, many industrial applications are being (re-)targeted to multiprocessor platforms. However, exactly reproducible data values at the outputs as function of the data and timing of the inputs is less trivial to realize in multiprocessors, while it can be imperative for various practical reasons. Also for parallel platforms it is harder to evaluate the task utilization and ensure schedulability, especially for end-to-end communication timing constraints and aperiodic events. Based upon reactive system extensions of Kahn process networks, we propose a model of computation that employs synchronous events and event priority relations to ensure deterministic execution. For this model, we propose an online scheduling policy and establish a link to a well-developed scheduling theory. We also implement this model in publicly available prototype tools and evaluate them on state-of-the art multi-core hardware, with a streaming benchmark and an avionics case study.},
  timestamp = {2017-05-30T16:20:22Z},
  booktitle = {2015 {{Design}}, {{Automation Test}} in {{Europe Conference Exhibition}} ({{DATE}})},
  author = {Poplavko, P. and Socci, D. and Bourgos, P. and Bensalem, S. and Bozga, M.},
  month = mar,
  year = {2015},
  keywords = {aperiodic events,avionics,avionics case study,deterministic execution,embedded real-time systems,end-to-end communication timing constraints,event priority relations,Generators,Kahn process network,multicore hardware,multiprocessing systems,online scheduling policy,parallel platforms,parallel processing,Processor scheduling,Program processors,reactive system extension,real-time multiprocessor applications,real-time systems,schedulability,Schedules,Semantics,Servers,streaming benchmark,synchronous events,task utilization},
  pages = {1665--1670},
  file = {Poplavko et al. - 2015 - Models for Deterministic Execution of Real-time Mu.pdf:/home/moiri/Dropbox/papers/Poplavko et al. - 2015 - Models for Deterministic Execution of Real-time Mu.pdf:application/pdf}
}

@book{tanenbaum2014,
  address = {Upper Saddle River, NJ, USA},
  edition = {4th},
  title = {Modern {{Operating Systems}}},
  isbn = {978-0-13-359162-0},
  abstract = {Modern Operating Systems, Fourth Edition, is intended for introductory courses in Operating Systems in Computer Science, Computer Engineering, and Electrical Engineering programs. It also serves as a useful reference for OS professionals The widely anticipated revision of this worldwide best-seller incorporates the latest developments in operating systems (OS) technologies. The Fourth Edition includes up-to-date materials on relevantOS. Tanenbaum also provides information on current research based on his experience as an operating systems researcher. Modern Operating Systems, Third Editionwas the recipient of the 2010 McGuffey Longevity Award. The McGuffey Longevity Award recognizes textbooks whose excellence has been demonstrated over time.http://taaonline.net/index.html Teaching and Learning Experience This program will provide a better teaching and learning experiencefor you and your students. It will help: Provide Practical Detail on the Big Picture Concepts: A clear and entertaining writing style outlines the concepts every OS designer needs to master. Keep Your Course Current: This edition includes information on the latest OS technologies and developments Enhance Learning with Student and Instructor Resources: Students will gain hands-on experience using the simulation exercises and lab experiments.},
  language = {english},
  timestamp = {2017-06-09T09:34:43Z},
  publisher = {{Prentice Hall Press}},
  author = {Tanenbaum, Andrew S. and Bos, Herbert},
  year = {2014},
  file = {Modern.Operating.Systems_Tannenbaum_4th.pdf:/home/moiri/Dropbox/books/Modern.Operating.Systems_Tannenbaum_4th.pdf:application/pdf}
}

@article{wilhelm2008,
  title = {The {{Worst}}-Case {{Execution}}-Time {{Problem}}\textemdash{}{{Overview}} of {{Methods}} and {{Survey}} of {{Tools}}},
  volume = {7},
  issn = {1539-9087},
  doi = {10.1145/1347375.1347389},
  abstract = {The determination of upper bounds on execution times, commonly called worst-case execution times (WCETs), is a necessary step in the development and validation process for hard real-time systems. This problem is hard if the underlying processor architecture has components, such as caches, pipelines, branch prediction, and other speculative components. This article describes different approaches to this problem and surveys several commercially available tools1 and research prototypes.},
  timestamp = {2017-06-19T14:54:51Z},
  number = {3},
  urldate = {2017-06-19},
  journal = {ACM Trans. Embed. Comput. Syst.},
  author = {Wilhelm, Reinhard and Engblom, Jakob and Ermedahl, Andreas and Holsti, Niklas and Thesing, Stephan and Whalley, David and Bernat, Guillem and Ferdinand, Christian and Heckmann, Reinhold and Mitra, Tulika and Mueller, Frank and Puaut, Isabelle and Puschner, Peter and Staschulat, Jan and Stenstr{\"o}m, Per},
  month = may,
  year = {2008},
  keywords = {Hard real time,worst-case execution times},
  pages = {36:1--36:53},
  file = {Wilhelm et al. - 2008 - The Worst-case Execution-time Problem—Overview of .pdf:/home/moiri/Dropbox/papers/Wilhelm et al. - 2008 - The Worst-case Execution-time Problem—Overview of .pdf:application/pdf}
}

@inproceedings{henzinger2006a,
  title = {An {{Interface Algebra}} for {{Real}}-{{Time Components}}},
  doi = {10.1109/RTAS.2006.11},
  abstract = {We present an assume-guarantee interface algebra for real-time components. In our formalism a component implements a set of task sequences that share a resource. A component interface consists of an arrival rate function and a latency for each task sequence, and a capacity function for the shared resource. The interface specifies that the component guarantees certain task latencies depending on assumptions about task arrival rates and allocated resource capacities. Our algebra defines compatibility and refinement relations on interfaces. Interface compatibility can be checked on partial designs, even when some component interfaces are yet unknown. In this case interface composition computes as new assumptions the weakest constraints on the unknown components that are necessary to satisfy the specified guarantees. Interface refinement is defined in a way that ensures that compatible interfaces can be refined and implemented independently. Our algebra thus formalizes an interface-based design methodology that supports both the incremental addition of new components and the independent stepwise refinement of existing components. We demonstrate the flexibility and efficiency of the framework through simulation experiments.},
  timestamp = {2017-06-22T17:08:12Z},
  booktitle = {12th {{IEEE Real}}-{{Time}} and {{Embedded Technology}} and {{Applications Symposium}} ({{RTAS}}'06)},
  author = {Henzinger, Thomas A. and Matic, Slobodan},
  month = apr,
  year = {2006},
  keywords = {algebra,Computer interfaces,Delay,Design methodology,embedded system,Real time systems,Resource management,Software engineering,Software systems,Timing},
  pages = {253--266},
  file = {Henzinger and Matic - 2006 - An Interface Algebra for Real-Time Components.pdf:/home/moiri/Dropbox/papers/Henzinger and Matic - 2006 - An Interface Algebra for Real-Time Components.pdf:application/pdf}
}

@incollection{kopetz2011c,
  edition = {2nd},
  title = {The {{Time}}-Triggered {{Architecture}}},
  isbn = {978-1-4419-8236-0},
  shorttitle = {Real-{{Time Systems}}},
  language = {english},
  timestamp = {2017-07-21T14:39:07Z},
  booktitle = {Real-{{Time Systems}}: {{Design Principles}} for {{Distributed Embedded Applications}}},
  publisher = {{Springer Publishing Company, Incorporated}},
  author = {Kopetz, Hermann},
  year = {2011},
  pages = {325--339}
}

@book{kopetz2011,
  edition = {2nd},
  title = {Real-{{Time Systems}}: {{Design Principles}} for {{Distributed Embedded Applications}}},
  isbn = {978-1-4419-8236-0},
  shorttitle = {Real-{{Time Systems}}},
  abstract = {"This book is a comprehensive text for the design of safety critical, hard real-time embedded systems. It offers a splendid example for the balanced, integrated treatment of systems and software engineering, helping readers tackle the hardest problems of advanced real-time system design, such as determinism, compositionality, timing and fault management. This book is an essential reading for advanced undergraduates and graduate students in a wide range of disciplines impacted by embedded computing and software. Its conceptual clarity, the style of explanations and the examples make the abstract conceptsaccessible for a wide audience."Janos Sztipanovits, DirectorE. Bronson Ingram Distinguished Professor of EngineeringInstitute for Software Integrated SystemsVanderbilt UniversityReal-Time Systems focuses on hard real-time systems, which are computing systems that must meet their temporal specification in all anticipated load and fault scenarios. The book stresses the system aspects of distributed real-time applications, treating the issues of real-time, distribution and fault-tolerance from an integral point of view. A unique cross-fertilization of ideas and concepts between the academic and industrial worlds has led to the inclusion of many insightful examples from industry to explain the fundamental scientific concepts in a real-world setting. Compared to the first edition, new developments incomplexity management,energy and power management, dependability, security, andthe internet of things, are addressed. The book is written as a standard textbook for a high-level undergraduate or graduate course on real-time embedded systems or cyber-physical systems. Its practical approach to solving real-time problems, along with numerous summary exercises, makes it an excellent choice for researchers and practitioners alike.},
  timestamp = {2017-07-12T14:53:17Z},
  publisher = {{Springer Publishing Company, Incorporated}},
  author = {Kopetz, Hermann},
  year = {2011},
  file = {Real.Time.Systems_Design.Principles.for.Distributed.Embedded.Applications_Kopetz_2nd.pdf:/home/moiri/Dropbox/books/Real.Time.Systems_Design.Principles.for.Distributed.Embedded.Applications_Kopetz_2nd.pdf:application/pdf}
}

@incollection{kopetz2011b,
  edition = {2nd},
  title = {Temporal {{Control Versus Logical Control}}},
  isbn = {978-1-4419-8236-0},
  shorttitle = {Real-{{Time Systems}}},
  language = {english},
  timestamp = {2017-07-12T15:00:32Z},
  booktitle = {Real-{{Time Systems}}: {{Design Principles}} for {{Distributed Embedded Applications}}},
  publisher = {{Springer Publishing Company, Incorporated}},
  author = {Kopetz, Hermann},
  year = {2011},
  pages = {82--84}
}

@article{groote1996,
  title = {Confluence for {{Process Verification}}},
  volume = {170},
  issn = {0304-3975},
  doi = {10.1016/S0304-3975(96)80702-X},
  abstract = {We provide several notions for confluence in processes and we show how these relate to $\tau$-inertness, i.e. if then s and s${'}$ are equivalent. Using clustered linear processes we show how these notions can conveniently be used to reduce the size of state spaces and simplify the structure of processes while preserving equivalence.},
  timestamp = {2017-07-13T16:20:54Z},
  number = {1},
  urldate = {2017-07-13},
  journal = {Theoretical Computer Science},
  author = {Groote, Jan F. and Sellink, Alex},
  month = dec,
  year = {1996},
  pages = {47--81},
  file = {Groote and Sellink - 1996 - Confluence for Process Verification.pdf:/home/moiri/Dropbox/papers/Groote and Sellink - 1996 - Confluence for Process Verification.pdf:application/pdf}
}

@incollection{kopetz2011a,
  edition = {2nd},
  title = {Task {{Management}}},
  isbn = {978-1-4419-8236-0},
  shorttitle = {Real-{{Time Systems}}},
  language = {english},
  timestamp = {2017-07-21T14:37:11Z},
  booktitle = {Real-{{Time Systems}}: {{Design Principles}} for {{Distributed Embedded Applications}}},
  publisher = {{Springer Publishing Company, Incorporated}},
  author = {Kopetz, Hermann},
  year = {2011},
  pages = {218--221}
}

@techreport{himsolt1996,
  address = {94030 Passau, Germany},
  type = {Techincal Report},
  title = {{{GML}}: {{A}} Portable {{Graph File Format}}},
  timestamp = {2017-07-26T16:54:35Z},
  institution = {Universit{\"a}t Passau},
  author = {Himsolt, Michael},
  year = {1996},
  file = {Himsolt - 1996 - GML A portable Graph File Format.pdf:/home/moiri/Dropbox/papers/Himsolt - 1996 - GML A portable Graph File Format.pdf:application/pdf}
}

@inproceedings{brandes2001,
  series = {Lecture Notes in Computer Science},
  title = {{{GraphML Progress Report Structural Layer Proposal}}},
  isbn = {978-3-540-43309-5 978-3-540-45848-7},
  doi = {10.1007/3-540-45848-4_59},
  abstract = {Following a workshop on graph data formats held with the 8th Symposium on Graph Drawing (GD 2000), a task group was formed to propose a format for graphs and graph drawings that meets current and projected requirements. On behalf of this task group, we here present GraphML (Graph Markup Language), an XML format for graph structures, as an initial step towards this goal. Its main characteristic is a unique mechanism that allows to de.ne extension modules for additional data, such as graph drawing information or data specific to a particular application. These modules can freely be combined or stripped without affecting the graph structure, so that information can be added (or omitted) in a well-defined way.},
  language = {en},
  timestamp = {2017-07-26T16:58:43Z},
  urldate = {2017-07-26},
  booktitle = {Graph {{Drawing}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Brandes, Ulrik and Eiglsperger, Markus and Herman, Ivan and Himsolt, Michael and Marshall, Scott M.},
  month = sep,
  year = {2001},
  pages = {501--512},
  file = {Brandes et al. - 2001 - GraphML Progress Report Structural Layer Proposal.pdf:/home/moiri/Dropbox/papers/Brandes et al. - 2001 - GraphML Progress Report Structural Layer Proposal.pdf:application/pdf}
}

@incollection{kopetz2011d,
  edition = {2nd},
  title = {The {{Message Concept}}},
  isbn = {978-1-4419-8236-0},
  shorttitle = {Real-{{Time Systems}}},
  language = {english},
  timestamp = {2017-08-11T11:52:12Z},
  booktitle = {Real-{{Time Systems}}: {{Design Principles}} for {{Distributed Embedded Applications}}},
  publisher = {{Springer Publishing Company, Incorporated}},
  author = {Kopetz, Hermann},
  year = {2011},
  pages = {88--91}
}

@article{liu2017,
  title = {Review on {{Cyber}}-Physical {{Systems}}},
  volume = {4},
  issn = {2329-9266},
  doi = {10.1109/JAS.2017.7510349},
  abstract = {Cyber-physical systems U+0028 CPS U+0029 are complex systems with organic integration and in-depth collaboration of computation, communications and control U+0028 3C U+0029 technology. Subject to the theory and technology of existing network systems and physical systems, the development of CPS is facing enormous challenges. This paper first introduces the concept and characteristics of CPS and analyzes the present situation of CPS researches. Then the development of CPS is discussed from perspectives of system model, information processing technology and software design. At last it analyzes the main obstacles and key researches in developing CPS.},
  timestamp = {2017-08-08T15:15:48Z},
  number = {1},
  journal = {IEEE/CAA Journal of Automatica Sinica},
  author = {Liu, Y. and Peng, Y. and Wang, B. and Yao, S. and Liu, Z.},
  month = jan,
  year = {2017},
  keywords = {complex systems,Computational modeling,Computers,CPS,cyber-physical systems,information processing technology,Internet,organic integration,Process control,real-time systems,social aspects of automation,software design,Wireless sensor networks},
  pages = {27--40},
  file = {Liu et al. - 2017 - Review on Cyber-physical Systems.pdf:/home/moiri/Dropbox/papers/Liu et al. - 2017 - Review on Cyber-physical Systems.pdf:application/pdf}
}

@article{deDinechin2013,
  series = {2013 International Conference on Computational Science},
  title = {A {{Distributed Run}}-{{Time Environment}} for the {{Kalray MPPA}}\textregistered-256 {{Integrated Manycore Processor}}},
  volume = {18},
  issn = {1877-0509},
  doi = {10.1016/j.procs.2013.05.333},
  abstract = {The Kalray MPPA\textregistered-256 is a single-chip manycore processor that integrates 256 user cores and 32 system cores in 28nm CMOS technology. These cores are distributed across 16 compute clusters of 16+1 cores, and 4 quad-core I/O subsystems. Each compute cluster and I/O subsystem owns a private address space, while communication and synchronization between them is ensured by data and control Networks-on-Chip (NoC). This processor targets embedded applications whose program- ming models fall within the following classes: Kahn Process Networks (KPN), as motivated by media processing; single program multiple data (SPMD), traditionally used for numerical kernels; and time-triggered control systems. We describe a run-time environment that supports these classes of programming models and their composition. This environment combines classic POSIX single-process multi-threaded execution inside the compute clusters and I/O subsystems, with a set of specific Inter-Process Communication (IPC) primitives that exploit the NoC architecture. We combine these primitives in order to provide the run-time support for the different target programming models. Interestingly enough, all these NoC-specific IPC primitives can be mapped to a subset of the classic synchronous and asynchronous POSIX file descriptor operations. This design thus extends the canonical `pipe-and-filters' software component model, where POSIX processes are the atomic components, and IPC instances are the connectors.},
  timestamp = {2017-08-18T17:35:10Z},
  urldate = {2017-08-16},
  journal = {Procedia Computer Science},
  author = {{de Dinechin}, Beno{\^\i}t Dupont and de Massas, Pierre Guironnet and Lager, Guillaume and L{\'e}ger, Cl{\'e}ment and Orgogozo, Benjamin and Reybert, J{\'e}r{\^o}me and Strudel, Thierry},
  month = jan,
  year = {2013},
  keywords = {Distributed Memory,Network-on-Chip,POSIX IPC},
  pages = {1654--1663},
  file = {Dinechin et al. - 2013 - A Distributed Run-Time Environment for the Kalray .pdf:/home/moiri/Dropbox/papers/Dinechin et al. - 2013 - A Distributed Run-Time Environment for the Kalray .pdf:application/pdf}
}

@inproceedings{thiele2006,
  address = {New York, NY, USA},
  series = {EMSOFT '06},
  title = {Real-Time {{Interfaces}} for {{Composing Real}}-Time {{Systems}}},
  isbn = {978-1-59593-542-7},
  doi = {10.1145/1176887.1176894},
  abstract = {Recently, a number of frameworks were proposed to extend interface theory to the domains of single-processor and distributed real-time systems. This paper unifies some of these approaches and proves properties like refinement and independent implementability. We also explicitly state the requirements to a framework for these properties to be fulfilled. Further, a new notion of adaptive interfaces is introduced that supports the design by providing mechanisms for propagating system constraints, such as (end-to-end) delays, available computing and communication resources, buffer spaces, and energy. Guarantees and assumptions on interfaces are not any longer static but adapt according to the system environment. This can be used to answer synthesis questions at design time or to adapt system parameters to changing environment requirements at run-time. The applicability of the presented framework is proven by adapting it to a number of different real-time analysis models.},
  timestamp = {2017-08-18T11:10:18Z},
  urldate = {2017-08-18},
  booktitle = {Proceedings of the 6th {{ACM}} \& {{IEEE International Conference}} on {{Embedded Software}}},
  publisher = {{ACM}},
  author = {Thiele, Lothar and Wandeler, Ernesto and Stoimenov, Nikolay},
  year = {2006},
  keywords = {adaptive interfaces,interface-based design,Performance analysis,real-time interfaces},
  pages = {34--43},
  file = {Thiele et al. - 2006 - Real-time Interfaces for Composing Real-time Systems.pdf:/home/moiri/Dropbox/papers/Thiele et al. - 2006 - Real-time Interfaces for Composing Real-time Systems.pdf:application/pdf}
}

@article{tan2008,
  title = {A {{Prototype Architecture}} for {{Cyber}}-Physical {{Systems}}},
  volume = {5},
  issn = {1551-3688},
  doi = {10.1145/1366283.1366309},
  abstract = {Cyber-Physical Systems (CPS) is an exciting emerging research area that has drawn the attention of many researchers. Although the question of "What is a CPS?" remains open, widely recognized and accepted attributes of a CPS include timeliness, distributed, reliability, fault-tolerance, security, scalability and autonomous. In this paper, a CPS definition is given and a prototype architecture is proposed. It is argued that this architecture captures the essential attributes of a CPS and lead to identification of many research challenges.},
  timestamp = {2017-08-18T17:53:26Z},
  number = {1},
  urldate = {2017-08-18},
  journal = {SIGBED Rev.},
  author = {Tan, Ying and Goddard, Steve and P{\'e}rez, Lance C.},
  month = jan,
  year = {2008},
  pages = {26:1--26:2},
  file = {Tan et al. - 2008 - A Prototype Architecture for Cyber-physical System.pdf:/home/moiri/Dropbox/papers/Tan et al. - 2008 - A Prototype Architecture for Cyber-physical System.pdf:application/pdf}
}

@article{lee2016,
  title = {Towards {{Compositional Mixed}}-Criticality {{Real}}-Time {{Scheduling}} in {{Open Systems}}: {{Invited Paper}}},
  volume = {13},
  issn = {1551-3688},
  shorttitle = {Towards {{Compositional Mixed}}-Criticality {{Real}}-Time {{Scheduling}} in {{Open Systems}}},
  doi = {10.1145/2983185.2983193},
  abstract = {Although many cyber-physical systems are both mixed-criticality system and compositional system, there are little work on intersection of mixed-criticality system and compositional system. We propose novel concepts for task-level criticality-mode and reconsider temporal isolation in terms of compositional mixed-criticality scheduling.},
  timestamp = {2017-08-18T18:35:22Z},
  number = {3},
  urldate = {2017-08-18},
  journal = {SIGBED Rev.  - Special Issue on 8th International Workshop on Compositional Theory and Technology for Real-Time Embedded Systems (CRTS 2015)},
  author = {Lee, Jaewoo and Chwa, Hoon Sung and Easwaran, Arvind and Shin, Insik and Lee, Insup},
  month = aug,
  year = {2016},
  pages = {49--51},
  file = {Lee et al. - 2016 - Towards Compositional Mixed-criticality Real-time .pdf:/home/moiri/Dropbox/papers/Lee et al. - 2016 - Towards Compositional Mixed-criticality Real-time .pdf:application/pdf}
}

@incollection{harel1985,
  series = {NATO ASI Series},
  title = {On the {{Development}} of {{Reactive Systems}}},
  isbn = {978-3-642-82455-5 978-3-642-82453-1},
  abstract = {Some observations are made concerning the process of developing complex systems. A broad class of systems, termed reactive, is singled out as being particularly problematic when it comes to finding satisfactory methods for behavioral description. In this paper we recommend the recently proposed statechart method for this purpose. Moreover, it is observed that most reactive systems cannot be developed in a linear stepwise fashion, but, rather, give rise to a two-dimensional development process, featuring behavioral aspects in the one dimension and implementational ones in the other. Concurrency may occur in both dimensions, as orthogonality of states in the one and as parallelism of subsystems in the other. A preliminary approach to working one's way through this ``magic square'' of system development is then presented. The ideas described herein seem to be relevant to a wide variety of application areas.},
  language = {en},
  timestamp = {2017-08-19T16:01:44Z},
  urldate = {2017-08-19},
  booktitle = {Logics and {{Models}} of {{Concurrent Systems}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  author = {Harel, David and Pnueli, Amir},
  year = {1985},
  pages = {477--498},
  file = {Harel and Pnueli - 1985 - On the Development of Reactive Systems.pdf:/home/moiri/Dropbox/papers/Harel and Pnueli - 1985 - On the Development of Reactive Systems.pdf:application/pdf},
  doi = {10.1007/978-3-642-82453-1_17}
}

@inproceedings{vestal2007,
  title = {Preemptive {{Scheduling}} of {{Multi}}-Criticality {{Systems}} with {{Varying Degrees}} of {{Execution Time Assurance}}},
  doi = {10.1109/RTSS.2007.47},
  abstract = {This paper is based on a conjecture that the more confidence one needs in a task execution time bound (the less tolerant one is of missed deadlines), the larger and more conservative that bound tends to become in practice. We assume different tasks perform functions having different criticalities and requiring different levels of assurance. We assume a task may have a set of alternative worst-case execution times, each assured to a different level of confidence. This paper presents ways to use this information to obtain more precise schedulability analysis and more efficient preemptive fixed priority scheduling. These methods are evaluated using workloads abstracted from production avionics systems.},
  timestamp = {2017-08-19T20:36:45Z},
  booktitle = {28th {{IEEE International Real}}-{{Time Systems Symposium}} ({{RTSS}} 2007)},
  author = {Vestal, Steve},
  month = dec,
  year = {2007},
  keywords = {Aerospace electronics,Algorithm design and analysis,avionics,avionics systems,Delay,execution time assurance,Iterative algorithms,multi-criticality systems,Performance analysis,preemptive fixed priority scheduling,Processor scheduling,Production systems,Real time systems,schedulability analysis,Scheduling algorithm,task execution time,Timing},
  pages = {239--243},
  file = {Vestal - 2007 - Preemptive Scheduling of Multi-criticality Systems.pdf:/home/moiri/Dropbox/papers/Vestal - 2007 - Preemptive Scheduling of Multi-criticality Systems.pdf:application/pdf}
}

@article{maurer2017,
  title = {Static {{Deadlock Analysis}} of {{Process Networks}} with {{Synchronous Interface Automata}}},
  timestamp = {2017-08-21T00:35:57Z},
  journal = {Ready for Submission},
  author = {Maurer, Simon and Kirner, Raimund and Tveretina, Olga},
  year = {2017}
}


